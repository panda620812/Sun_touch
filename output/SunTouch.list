				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\MAIN_PROGRAM_V104\MAIN_PROGRAM_V104.asm
				;1	
				;2	message '****************************************************************'
				;3	message '*PROJECT NAME :MAIN PROGRAM V104                               *'
				;4	message '*     VERSION :V104                                            *'
				;5	message '* ICE VERSION :                                                *'
				;6	message '*      DATE   :20160302                                        *'
				;7	message '*      REMARK :V104 add 33~36 key                              *'
				;8	message '****************************************************************'
				;9	                ;=INCLUDE REFERENCE FILE
				;10	                INCLUDE MAIN_PROGRAM_V104.INC
				;11	
				;12	                ;-PUBLIC LABEL
				;13	                PUBLIC  _LOAD_TKS_GLOBE_VARIES
				;14	                PUBLIC  _LOAD_HXT_REFERENCE
				;15	
				;16	CALL_   MACRO   FUNCTION
				;17	        ifdef   FUNCTION
				;18	                ifdef   PBP
				;19	                MOV     A,bank FUNCTION
				;20	                MOV     PBP,A
				;21	                endif
				;22	                CALL    FUNCTION
				;23	        endif
				;24	                ENDM
				;25					
				;26					
				;27					
				;28					
				;29	EXTEND_FUNCTION_INITIAL MACRO
				;30	                CALL_   EXTEND_FUNCTION_1A_INITIAL
				;31	                CALL_   EXTEND_FUNCTION_1B_INITIAL
				;32	                CALL_   EXTEND_FUNCTION_1C_INITIAL
				;33	                CALL_   EXTEND_FUNCTION_1D_INITIAL
				;34	                CALL_   EXTEND_FUNCTION_1E_INITIAL
				;35	                CALL_   EXTEND_FUNCTION_1F_INITIAL
				;36	                CALL_   EXTEND_FUNCTION_1G_INITIAL
				;37	                CALL_   EXTEND_FUNCTION_1H_INITIAL
				;38	
				;39	                CALL_   EXTEND_FUNCTION_2A_INITIAL
				;40	                CALL_   EXTEND_FUNCTION_2B_INITIAL
				;41	                CALL_   EXTEND_FUNCTION_2C_INITIAL
				;42	                CALL_   EXTEND_FUNCTION_2D_INITIAL
				;43	                CALL_   EXTEND_FUNCTION_2E_INITIAL
				;44	                CALL_   EXTEND_FUNCTION_2F_INITIAL
				;45	                CALL_   EXTEND_FUNCTION_2G_INITIAL
				;46	                CALL_   EXTEND_FUNCTION_2H_INITIAL
				;47	                ENDM
				;48	
				;49	EXTEND_FUNCTION MACRO
				;50	                CALL_   EXTEND_FUNCTION_1A
				;51	                CALL_   EXTEND_FUNCTION_1B
				;52	                CALL_   EXTEND_FUNCTION_1C
				;53	                CALL_   EXTEND_FUNCTION_1D
				;54	                CALL_   EXTEND_FUNCTION_1E
				;55	                CALL_   EXTEND_FUNCTION_1F
				;56	                CALL_   EXTEND_FUNCTION_1G
				;57	                CALL_   EXTEND_FUNCTION_1H
				;58	
				;59	                CALL_   EXTEND_FUNCTION_2A
				;60	                CALL_   EXTEND_FUNCTION_2B
				;61	                CALL_   EXTEND_FUNCTION_2C
				;62	                CALL_   EXTEND_FUNCTION_2D
				;63	                CALL_   EXTEND_FUNCTION_2E
				;64	                CALL_   EXTEND_FUNCTION_2F
				;65	                CALL_   EXTEND_FUNCTION_2G
				;66	                CALL_   EXTEND_FUNCTION_2H
				;67	                ENDM
				;68	                ;==============
				;69	                ;=DATA SETCTION
				;70	                ;==============
				;71	MAIN_DATA       .SECTION          'DATA'
				;72	
				;73	ifndef  ESCpowerIDcheck
				;74	POR_ID          DB      2 DUP(?)
				;75	endif
				;76	
				;77	
				;78	
				;79	                ;==============
				;80	                ;=CODE SETCTION
				;81	                ;==============
				;82	PROGRAM_ENTRY   .SECTION  AT 000H 'CODE'
				;83	        ifdef   PBP
				;84	                CLR     PBP
				;85	                ifndef  ESCpowerIDcheck
				;86	                MOV     A,042H      ;ASCII = B
				;87	                endif
				;88	        else
				;89	                ;----------------
				;90	                ;-SET POR ID 1---
				;91	                ;----------------
				;92	                ifndef  ESCpowerIDcheck
				;93	                MOV     A,042H      ;ASCII = B
				PROGRAM_ENTRY:
				include BS84B08A-3.inc
0000	0F42	mov     a, 42H
				;94	                SNZ     TO
0001	3A8A	snz     TO
				;95	                MOV     POR_ID[0],A
0002	4083	mov     POR_ID, a
				;96	                endif
				;97	        endif
				;98	                JMP     PROGRAM_RESET
0003	2C9D	jmp     PROGRAM_RESET
0004	0000	nop
0005	0000	nop
0006	0000	nop
0007	0000	nop
					----
					----
				;99	
				;100	                ;==============
				;101	                ;=MAIN PROGRAM=
				;102	                ;==============
				;103	MAIN_PROGRAM    .SECTION          'CODE'
				;104	
				;105	                ;;***********************
				;106	PROGRAM_RESET:  ;;* PROGRAM ENTRY *******
				;107	                ;;***********************
				;108	        ifdef   PBP
				;109	                ifndef  ESCpowerIDcheck
				;110	                SNZ     TO
				;111	                MOV     POR_ID[0],A
				;112	                endif
				;113	        endif
				;114	                ;----------------
				;115	                ;-SET POR ID 2---
				;116	                ;----------------
				;117	        ifndef  ESCpowerIDcheck
				;118	                MOV     A,053H      ;ASCII = S
				PROGRAM_RESET:
				MAIN_PROGRAM:
049D	0F53	mov     a, 53H
				;119	                MOV     POR_ID[1],A
049E	4084	mov     POR_ID[1], a
				;120	        endif
				;121	
				;122	
				;123	                ;---------------------
				;124	                ;-MCU HARDWARE INITIAL
				;125	                ;---------------------
				;126	                MCU_HARDWARE_INITIAL
049F	0F30	mov     a, 30H
04A0	008C	mov     CTRL, a
04A1	0F03	mov     a, 3H
04A2	008B	mov     SMOD, a
04A3	0F52	mov     a, 52H
04A4	009A	mov     WDTC, a
04A5	1F32	clr     ACERL
04A6	0F60	mov     a, 60H
04A7	00B0	mov     ADCR0, a
04A8	1F31	clr     ADCR1
04A9	0F01	mov     a, 1H
04AA	0084	mov     BP, a
04AB	0F80	mov     a, 80H
04AC	24CA	call    CLEAR_RAM
04AD	1F04	clr     BP
04AE	0F60	mov     a, 60H
04AF	24CA	call    CLEAR_RAM
				;127	
				;128	;-------------------------------------------------
				;129			ifdef DevOverStack
				;130					mov		A,DevOverStack+1	
				;131	Keep_Stack:
				;132					sdz		ACC
				;133					call	Keep_Stack
				;134			endif
				;135	;-------------------------------------------------
				;136	
				;137	                ;------------------------------
				;138	                ;-LOAD LIBRARY OPTION/THRESHOLD
				;139	                ;------------------------------
				;140	                CALL    _LOAD_TKS_GLOBE_VARIES
04B0	24D7	call    _LOAD_HXT_REFERENCE
				;141					
				;142	                ;------------------------
				;143	                ;-EXTEND FUNCTION INITIAL
				;144	                ;------------------------
				;145	                EXTEND_FUNCTION_INITIAL
04B1	208C	call    L008C
04B2	200A	call    _USER_PROGRAM_INITIAL
04B3	60F2	call    _LEDX4_V16_INITIAL
				;146	
				;147	                ;;-----------------------
				;148	MAIN_LOOP:      ;;- MAIN PROGRAM LOOP ---
				;149	                ;;-----------------------
				;150	                CLR     WDT
				MAIN_LOOP:
04B4	0001	clr     wdt
				;151	                CLR     WDT1
04B5	0001	clr     wdt
				;152	                CLR     WDT2
04B6	0005	clr     wdt2
				;153	
				;154	                ;----------------
				;155	                ;-CHECK POR ID --
				;156	                ;----------------
				;157	        ifndef  ESCpowerIDcheck
				;158	                MOV     A,042H
04B7	0F42	mov     a, 42H
				;159	                XORM    A,POR_ID[0]
04B8	4483	xorm    a, POR_ID
				;160	                MOV     A,053H
04B9	0F53	mov     a, 53H
				;161	                SZ      Z
04BA	3D0A	sz      Z
				;162	                XORM    A,POR_ID[1]
04BB	4484	xorm    a, POR_ID[1]
				;163	                SNZ     Z
04BC	390A	snz     Z
				;164	                JMP     000H
04BD	2800	jmp     PROGRAM_ENTRY
				;165	        endif
				;166	                ;----------------------
				;167	                ;-RE INITIAL SYS. CLOCK
				;168	                ;----------------------
				;169	                RELOAD_SYS_CLOCK
04BE	0F30	mov     a, 30H
04BF	008C	mov     CTRL, a
04C0	0F03	mov     a, 3H
04C1	008B	mov     SMOD, a
				;170	                EXTEND_FUNCTION
04C2	2018	call    L0018
04C3	200B	call    _USER_PROGRAM
04C4	6313	call    _LEDX4_V16
				;171	                ;----------------
				;172	                ;-SET POR ID  ---
				;173	                ;----------------
				;174	        ifndef  ESCpowerIDcheck
				;175	                MOV     A,042H      ;ASCII = B
04C5	0F42	mov     a, 42H
				;176	                MOV     POR_ID[0],A
04C6	4083	mov     POR_ID, a
				;177	                MOV     A,053H      ;ASCII = S
04C7	0F53	mov     a, 53H
				;178	                MOV     POR_ID[1],A
04C8	4084	mov     POR_ID[1], a
				;179	        endif
				;180	
				;181	                ;--------------------
				;182	WDT_WAKEUP:     ;-WDT WAKEUP FUNCTION
				;183	                ;--------------------
				;184	                if      PowerSave==1
				;185	                CALL_   _CHECK_KEY_WAKEUP
				;186	                endif
				;187	
				;188	                ifdef   PBP
				;189	                MOV     A,BANK MAIN_LOOP
				;190	                MOV     PBP,A
				;191	                endif
				;192	                JMP     MAIN_LOOP
				WDT_WAKEUP:
04C9	2CB4	jmp     MAIN_LOOP
				;193	
				;194	
				;195	
				;196	
				;197	
				;198	
				;199	
				;200	
				;201	
				;202	;;***********************************************************
				;203	;;*SUB. NAME:                                               *
				;204	;;*INPUT    :                                               *
				;205	;;*OUTPUT   :                                               *
				;206	;;*USED REG.:                                               *
				;207	;;*FUNCTION :                                               *
				;208	;;***********************************************************
				;209	CLEAR_RAM:
				;210	                MOV     MP1,A
				CLEAR_RAM:
04CA	0083	mov     MP1, a
				;211	        ifndef  ESCpowerIDcheck
				;212	            ifdef  BP
				;213	                ;-CHECK BANK
				;214	                SZ      BP
04CB	1084	sz      BP
				;215	                JMP     CLR_RAM
04CC	2CD3	jmp     CLR_RAM
				;216	            endif
				;217	                ;-CHECK POR_ID RAM
				;218	                MOV     A,OFFSET POR_ID
04CD	0F83	mov     a, 83H
				;219	                XOR     A,MP1
04CE	0403	xor     a, MP1
				;220	                MOV     A,OFFSET POR_ID+1
04CF	0F84	mov     a, 84H
				;221	                SNZ     Z
04D0	390A	snz     Z
				;222	                XOR     A,MP1
04D1	0403	xor     a, MP1
				;223	                SNZ     Z
04D2	390A	snz     Z
				;224	        endif
				;225	CLR_RAM:        ;-CLEAR RAM
				;226	                CLR     IAR1
				CLR_RAM:
04D3	1F02	clr     [02H]
				;227	                SIZA    MP1
04D4	1603	siza    MP1
				;228	                JMP     CLEAR_RAM
04D5	2CCA	jmp     CLEAR_RAM
				;229	
				;230	                RET
04D6	0003	ret
				;231	
				;232	
				;233	;;***********************************************************
				;234	;;*SUB. NAME:                                               *
				;235	;;*INPUT    :                                               *
				;236	;;*OUTPUT   :                                               *
				;237	;;*USED REG.:                                               *
				;238	;;*FUNCTION :                                               *
				;239	;;***********************************************************
				;240	_LOAD_TKS_GLOBE_VARIES:
				;241	_LOAD_HXT_REFERENCE:
				;242	                ;------------------------
				;243	                ;-SET TKS LIBRARY OPTION-
				;244	                ;------------------------
				;245	                MOV     A,GlobeOptionA
				_LOAD_HXT_REFERENCE:
				_LOAD_TKS_GLOBE_VARIES:
04D7	0FF1	mov     a, F1H
				;246	                MOV     _GLOBE_VARIES[0],A
04D8	00E0	mov     __pdpu[41], a
				;247	                MOV     A,GlobeOptionB
04D9	0F00	mov     a, 0H
				;248	                MOV     _GLOBE_VARIES[1],A
04DA	00E1	mov     __pdpu[42], a
				;249	                MOV     A,GlobeOptionC
04DB	0F30	mov     a, 30H
				;250	                MOV     _GLOBE_VARIES[2],A
04DC	00E2	mov     __pdpu[43], a
				;251	
				;252	                ;--------------------------
				;253	                ;-SET TOUCH OR IO ATTRIBUTE
				;254	                ;--------------------------
				;255	                MOV     A,IO_TOUCH_ATTR&0FFH
04DD	0F19	mov     a, 19H
				;256	                MOV     _KEY_IO_SEL[0],A
04DE	00F6	mov     __pdpu[63], a
				;257	                ;-IF OVER 2 TOUCH IP (8~16KEY)
				;258	                if      TouchKeyAmount > 8
				;259	                MOV     A,(IO_TOUCH_ATTR>>8)&0FFH
				;260	                MOV     _KEY_IO_SEL[1],A
				;261	                endif
				;262	                ;-IF OVER 4 TOUCH IP (17~24KEY)
				;263	                if      TouchKeyAmount > 16
				;264	                MOV     A,(IO_TOUCH_ATTR>>16)&0FFH
				;265	                MOV     _KEY_IO_SEL[2],A
				;266	                endif
				;267	                ;-IF OVER 6 TOUCH IP (25~32KEY)
				;268	                if      TouchKeyAmount > 24
				;269	                MOV     A,(IO_TOUCH_ATTR>>24)&0FFH
				;270	                MOV     _KEY_IO_SEL[3],A
				;271	                endif
				;272	
				;273	                ;-IF OVER 6 TOUCH IP (33~36KEY)
				;274	                if      TouchKeyAmount > 32
				;275	                MOV     A,IO_TOUCH_ATTR2
				;276	                MOV     _KEY_IO_SEL[4],A
				;277	                endif
				;278	
				;279	                ;------------------------
				;280	                ;-SET TOUCH KEY THRESHOLD
				;281	                ;------------------------
				;282	                ;-KEY1 THRESHOLD
				;283	                MOV     A,Key1Threshold
04DF	0F10	mov     a, 10H
				;284	                MOV     _GLOBE_VARIES[3],A
04E0	00E3	mov     __pdpu[44], a
				;285	
				;286	                if      TouchKeyAmount > 1
				;287	                ;-KEY2 THRESHOLD
				;288	                MOV     A,Key2Threshold
04E1	0F10	mov     a, 10H
				;289	                MOV     _GLOBE_VARIES[4],A
04E2	00E4	mov     __pdpu[45], a
				;290	                endif
				;291	
				;292	                if      TouchKeyAmount > 2
				;293	                ;-KEY3 THRESHOLD
				;294	                MOV     A,Key3Threshold
04E3	0F10	mov     a, 10H
				;295	                MOV     _GLOBE_VARIES[5],A
04E4	00E5	mov     __pdpu[46], a
				;296	                endif
				;297	
				;298	                if      TouchKeyAmount > 3
				;299	                ;-KEY4 THRESHOLD
				;300	                MOV     A,Key4Threshold
04E5	0F10	mov     a, 10H
				;301	                MOV     _GLOBE_VARIES[6],A
04E6	00E6	mov     __pdpu[47], a
				;302	                endif
				;303	
				;304	                if      TouchKeyAmount > 4
				;305	                ;-KEY5 THRESHOLD
				;306	                MOV     A,Key5Threshold
04E7	0F19	mov     a, 19H
				;307	                MOV     _GLOBE_VARIES[7],A
04E8	00E7	mov     __pdpu[48], a
				;308	                endif
				;309	
				;310	                if      TouchKeyAmount > 5
				;311	                ;-KEY6 THRESHOLD
				;312	                MOV     A,Key6Threshold
04E9	0F10	mov     a, 10H
				;313	                MOV     _GLOBE_VARIES[8],A
04EA	00E8	mov     __pdpu[49], a
				;314	                endif
				;315	
				;316	                if      TouchKeyAmount > 6
				;317	                ;-KEY7 THRESHOLD
				;318	                MOV     A,Key7Threshold
04EB	0F10	mov     a, 10H
				;319	                MOV     _GLOBE_VARIES[9],A
04EC	00E9	mov     __pdpu[50], a
				;320	                endif
				;321	
				;322	                if      TouchKeyAmount > 7
				;323	                ;-KEY8 THRESHOLD
				;324	                MOV     A,Key8Threshold
04ED	0F10	mov     a, 10H
				;325	                MOV     _GLOBE_VARIES[10],A
04EE	00EA	mov     __pdpu[51], a
				;326	                endif
				;327	
				;328	                if     TouchKeyAmount > 8
				;329	                ;-KEY9 THRESHOLD
				;330	                MOV     A,Key9Threshold
				;331	                MOV     _GLOBE_VARIES[11],A
				;332	                endif
				;333	
				;334	                if      TouchKeyAmount > 9
				;335	                ;-KEY10 THRESHOLD
				;336	                MOV     A,Key10Threshold
				;337	                MOV     _GLOBE_VARIES[12],A
				;338	                endif
				;339	
				;340	                if      TouchKeyAmount > 10
				;341	                ;-KEY11 THRESHOLD
				;342	                MOV     A,Key11Threshold
				;343	                MOV     _GLOBE_VARIES[13],A
				;344	                endif
				;345	
				;346	                if      TouchKeyAmount > 11
				;347	                ;-KEY12 THRESHOLD
				;348	                MOV     A,Key12Threshold
				;349	                MOV     _GLOBE_VARIES[14],A
				;350	                endif
				;351	
				;352	                if      TouchKeyAmount > 12
				;353	                ;-KEY13 THRESHOLD
				;354	                MOV     A,Key13Threshold
				;355	                MOV     _GLOBE_VARIES[15],A
				;356	                endif
				;357	
				;358	                if      TouchKeyAmount > 13
				;359	                ;-KEY14 THRESHOLD
				;360	                MOV     A,Key14Threshold
				;361	                MOV     _GLOBE_VARIES[16],A
				;362	                endif
				;363	
				;364	                if      TouchKeyAmount > 14
				;365	                ;-KEY15 THRESHOLD
				;366	                MOV     A,Key15Threshold
				;367	                MOV     _GLOBE_VARIES[17],A
				;368	                endif
				;369	
				;370	                if      TouchKeyAmount > 15
				;371	                ;-KEY16 THRESHOLD
				;372	                MOV     A,Key16Threshold
				;373	                MOV     _GLOBE_VARIES[18],A
				;374	                endif
				;375	
				;376	                if      TouchKeyAmount > 16
				;377	                ;-KEY17 THRESHOLD
				;378	                MOV     A,Key17Threshold
				;379	                MOV     _GLOBE_VARIES[19],A
				;380	                endif
				;381	
				;382	                if      TouchKeyAmount > 17
				;383	                ;-KEY18 THRESHOLD
				;384	                MOV     A,Key18Threshold
				;385	                MOV     _GLOBE_VARIES[20],A
				;386	                endif
				;387	
				;388	                if      TouchKeyAmount > 18
				;389	                ;-KEY19 THRESHOLD
				;390	                MOV     A,Key19Threshold
				;391	                MOV     _GLOBE_VARIES[21],A
				;392	                endif
				;393	
				;394	                if      TouchKeyAmount > 19
				;395	                ;-KEY20 THRESHOLD
				;396	                MOV     A,Key20Threshold
				;397	                MOV     _GLOBE_VARIES[22],A
				;398	                endif
				;399	
				;400	                if      TouchKeyAmount > 20
				;401	                ;-KEY17 THRESHOLD
				;402	                MOV     A,Key21Threshold
				;403	                MOV     _GLOBE_VARIES[23],A
				;404	                endif
				;405	
				;406	                if      TouchKeyAmount > 21
				;407	                ;-KEY18 THRESHOLD
				;408	                MOV     A,Key22Threshold
				;409	                MOV     _GLOBE_VARIES[24],A
				;410	                endif
				;411	
				;412	                if      TouchKeyAmount > 22
				;413	                ;-KEY19 THRESHOLD
				;414	                MOV     A,Key23Threshold
				;415	                MOV     _GLOBE_VARIES[25],A
				;416	                endif
				;417	
				;418	                if      TouchKeyAmount > 23
				;419	                ;-KEY20 THRESHOLD
				;420	                MOV     A,Key24Threshold
				;421	                MOV     _GLOBE_VARIES[26],A
				;422	                endif
				;423	
				;424	                if      TouchKeyAmount > 24
				;425	                ;-KEY17 THRESHOLD
				;426	                MOV     A,Key25Threshold
				;427	                MOV     _GLOBE_VARIES[27],A
				;428	                endif
				;429	
				;430	                if      TouchKeyAmount > 25
				;431	                ;-KEY18 THRESHOLD
				;432	                MOV     A,Key26Threshold
				;433	                MOV     _GLOBE_VARIES[28],A
				;434	                endif
				;435	
				;436	                if      TouchKeyAmount > 26
				;437	                ;-KEY19 THRESHOLD
				;438	                MOV     A,Key27Threshold
				;439	                MOV     _GLOBE_VARIES[29],A
				;440	                endif
				;441	
				;442	                if      TouchKeyAmount > 27
				;443	                ;-KEY20 THRESHOLD
				;444	                MOV     A,Key28Threshold
				;445	                MOV     _GLOBE_VARIES[30],A
				;446	                endif
				;447	
				;448	                if      TouchKeyAmount > 28
				;449	                ;-KEY29 THRESHOLD
				;450	                MOV     A,Key29Threshold
				;451	                MOV     _GLOBE_VARIES[31],A
				;452	                endif
				;453	
				;454	                if      TouchKeyAmount > 29
				;455	                ;-KEY30 THRESHOLD
				;456	                MOV     A,Key30Threshold
				;457	                MOV     _GLOBE_VARIES[32],A
				;458	                endif
				;459	
				;460	                if      TouchKeyAmount > 30
				;461	                ;-KEY31 THRESHOLD
				;462	                MOV     A,Key31Threshold
				;463	                MOV     _GLOBE_VARIES[33],A
				;464	                endif
				;465	
				;466	                if      TouchKeyAmount > 31
				;467	                ;-KEY32 THRESHOLD
				;468	                MOV     A,Key32Threshold
				;469	                MOV     _GLOBE_VARIES[34],A
				;470	                endif
				;471	
				;472	                if      TouchKeyAmount > 32
				;473	                ;-KEY33 THRESHOLD
				;474	                MOV     A,Key33Threshold
				;475	                MOV     _GLOBE_VARIES[35],A
				;476	                endif
				;477	
				;478	                if      TouchKeyAmount > 33
				;479	                ;-KEY34 THRESHOLD
				;480	                MOV     A,Key34Threshold
				;481	                MOV     _GLOBE_VARIES[36],A
				;482	                endif
				;483	
				;484	                if      TouchKeyAmount > 34
				;485	                ;-KEY35 THRESHOLD
				;486	                MOV     A,Key35Threshold
				;487	                MOV     _GLOBE_VARIES[37],A
				;488	                endif
				;489	
				;490	                if      TouchKeyAmount > 35
				;491	                ;-KEY36 THRESHOLD
				;492	                MOV     A,Key36Threshold
				;493	                MOV     _GLOBE_VARIES[38],A
				;494	                endif
				;495	
				;496	
				;497	                RET
04EF	0003	ret
				;498	
				;499	
				;500	
				;501	
				;502	                END
				;503	
				;504	
				;505	
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\USER_PROGRAM\USER_PROGRAM.asm
				;1	
				;2	
				;3	message '***************************************************************'
				;4	message '*PROJECT NAME :USER PROGRAM CODE                              *'
				;5	message '*     VERSION :                                               *'
				;6	message '*     IC BODY :                                               *'
				;7	message '* ICE VERSION :                                               *'
				;8	message '*      REMARK :                                               *'
				;9	message '***************************************************************'
				;10	
				;11	                ;INCLUDE HXT_REFERENCE.INC
				;12	                ;INCLUDE "..\HXT_REFERENCE.INC"
				;13	                INCLUDE USER_PROGRAM.INC
				;14	
				;15	                PUBLIC  _USER_PROGRAM_INITIAL
				;16	                PUBLIC  _USER_PROGRAM
				;17	
				;18	
				;19	                ;========================
				;20	                ;=USER DATA DEFINE      =
				;21	                ;========================
				;22	USER_DATA       .SECTION   'DATA'
				;23	
				;24	
				;25	
				;26	                ;========================
				;27	                ;=USER PROGRAM          =
				;28	                ;========================
				;29	USER_PROGRAM    .SECTION   'CODE'
				;30	
				;31	;;***********************************************************
				;32	;;*SUB. NAME:USER INITIAL PROGRAM                           *
				;33	;;*INPUT    :                                               *
				;34	;;*OUTPUT   :                                               *
				;35	;;*USED REG.:                                               *
				;36	;;*FUNCTION :                                               *
				;37	;;***********************************************************
				;38	                      ;;************************
				;39	_USER_PROGRAM_INITIAL:;;* USER_PROGRAM_INITIAL *
				;40	                      ;;************************
				;41	
				;42	                ;CLR     PAC
				;43	                ;CLR     PA
				;44	                ;CLR     PBC
				;45	                ;CLR     PB
				;46	                ;CLR     PCC
				;47	                ;CLR     PC
				;48	
				;49	
				;50	                RET
				_USER_PROGRAM_INITIAL:
				USER_PROGRAM:
000A	0003	ret
				;51	
				;52	
				;53	
				;54	
				;55	;;***********************************************************
				;56	;;*SUB. NAME:USER_MAIN                                      *
				;57	;;*INPUT    :                                               *
				;58	;;*OUTPUT   :                                               *
				;59	;;*USED REG.:                                               *
				;60	;;*FUNCTION :                                               *
				;61	;;***********************************************************
				;62	                ;;********************
				;63	_USER_PROGRAM:  ;;USER PROGRAM ENTRY *
				;64	                ;;********************
				;65	
				;66	
				;67	                ;CALL    _GET_KEY_BITMAP
				;68	                ;;MOV     A,_DATA_BUF[0]
				;69	                ;;OR      A,_DATA_BUF[1]
				;70	                ;;SZ      Z
				;71	                ;;CLR     PA.4
				;72	                ;;SNZ     Z
				;73	                ;;SET     PA.4
				;74	                ;;
				;75	                ;;SZ      _DATA_BUF[0].0
				;76	                ;;SET     PA.1
				;77	                ;;SNZ     _DATA_BUF[0].0
				;78	                ;;CLR     PA.1
				;79	
				;80	                RET
				_USER_PROGRAM:
000B	0003	ret
				;81	
				;82	
				;83	
				;84	
				;85	
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\LEDX4_V16\LEDX4_V16.c
				;1	// ==============================================
				;2	// LEDX4_V16.C: create by CompSysFileMaker.
				;3	// November 22, 2017 10:43:23
				;4	// ==============================================
				;5	#include "LEDX4_V16.h"
				;6	#include ".\Inc\TIM1628.h"
				;7	#include ".\Inc\Key.h"
				;8	#include ".\Inc\IRCHQB.h"
				;9	
				;10	#include ".\Src\TIM1628.c"
				;11	#include ".\Src\Key.c"
				;12	#include ".\Src\IRCHQB.c"
				;13	
				;14	//Timer Interrupt
				;15	void __attribute__((interrupt(0x0c))) isr_timer(void) ;		//定时器	
				;16	
				;17	void TimerSetFun( unsigned long TimerCountValieSet )
				;18	{
				;19		TimerClose;\
				_TimerSetFun:
				_TimerSetFun:
0788	361D	clr     TON
				;20		timerCount = 0;\
0789	5F36	clr     timerCount[0]
078A	5F37	clr     timerCount[1]
078B	5F38	clr     timerCount[2]
078C	5F39	clr     timerCount[3]
				;21		timerCountSet = TimerCountValieSet;\
078D	475D	mov     a, TimerCountValieSet[0]
078E	40BA	mov     timerCountSet[0], a
078F	475E	mov     a, TimerCountValieSet[1]
0790	40BB	mov     timerCountSet[1], a
0791	475F	mov     a, TimerCountValieSet[2]
0792	40BC	mov     timerCountSet[2], a
0793	4760	mov     a, TimerCountValieSet[3]
0794	40BD	mov     timerCountSet[3], a
				;22		TimerOpen;\
0795	321D	set     TON
				;23		timerFlag = Open;
0796	0F01	mov     a, 1H
0797	40B5	mov     timerFlag[0], a
0798	0003	ret
				;24	}
				;25	void delay()
				;26	{
				;27	     volatile unsigned int  i,j;
				;28	     for(i=0;i<50;i++)
				_delay:
				_delay:
0799	5F5F	clr     i[0]
079A	5F60	clr     i[1]
079B	2FAC	jmp     _L89
				_L93:
07A9	54DF	inc     i[0]
07AA	3D0A	sz      Z
07AB	54E0	inc     i[1]
				_L89:
07AC	0F31	mov     a, 31H
07AD	425F	sub     a, i[0]
07AE	0F00	mov     a, 0H
07AF	5260	sbc     a, i[1]
07B0	3C0A	sz      C
07B1	2F9C	jmp     _L92
07B2	0003	ret
				;29	     for(j=0;j<1000;j++)     
				_L92:
079C	5F5D	clr     j[0]
079D	5F5E	clr     j[1]
				_L90:
079E	0FE7	mov     a, E7H
079F	425D	sub     a, j[0]
07A0	0F03	mov     a, 3H
07A1	525E	sbc     a, j[1]
07A2	380A	snz     C
07A3	2FA9	jmp     _L93
07A5	54DD	inc     j[0]
07A6	3D0A	sz      Z
07A7	54DE	inc     j[1]
07A8	2F9E	jmp     _L90
				;30	     {
				;31	     	GCC_CLRWDT();
07A4	0001	clr     wdt
				;32	     }	
				;33	}
				;34	//***********************************************************
				;35	//	Timer
				;36	//***********************************************************
				;37	void timerInit(void)
				;38	{
				;39	      _tmr= 0 ;//256-250;    // 设置2MS中断 
				_timerInit:
				_timerInit:
07B3	1F1C	clr     TMR
				;40	      //从预置寄存器所载入的值开始计数， 到 FFH 时定时器溢出且会产生ISR
				;41	      _tmrc=0x06;	   // TS=FSYS, TON=0，64分频	
07B4	0F06	mov     a, 6H
07B5	009D	mov     TMRC, a
				;42	       //	0b00000011
				;43	       //   	|| |||
				;44	       //		|| 分频
				;45	       //		|控制位
				;46	       //       |时钟源	  
				;47	       //		
				;48			//前面表示中断类型的缩写， 紧接着的字母“E”代表使能 / 除能位， “F”代表请求标志位。	
				;49			//要使定时 / 计数器中断发生， 总中断控制位 EMI 和相应的内部中断使能位 TE必须先被置位 
				;50			//上电后预置寄存器_tmr处于未知状态。 为了得到定时器的最大计算范围FFH， 预置寄存器需要先清为零
				;51			//如果定时 / 计数器在关闭条件下， 写数据到预置寄存器， 会立即写入实际的定时器。 而如果定时 / 计数器已经打开
				;52			//且正在计数， 在这个周期内写入到预置寄存器的任何新数据将保留在预置寄存器， 直到溢出发生时才被写入实际定时器。
				;53			//定时 / 计数控制寄存器的第 4 位即 TON， 用于定时器开关控制， 设定为逻辑高时， 计数器开始计数， 而清零时则停止计数。 定时 / 计数控制寄存器的第 0~2
				;54			//位用来控制输入时钟预分频器。 TS 位用来选择内部时钟源。
				;55		  _te=1; 		   // 开定时器中断     
07B6	318E	set     TE
				;56		  _tf=0;           // 清零溢出标记
07B7	370E	clr     TF
				;57	      _emi=1;          // 开总中断
07B8	300E	set     EMI
				;58	      _ton=0;	       // 定时器开始运行	
07B9	361D	clr     TON
07BA	0003	ret
				;59	}
				;60	//***********************************************************
				;61		
				;62	//		TouchFun
				;63	 
				;64	//***********************************************************
				;65	 //触摸及显示
				;66	 void TouchFun(void)
				;67	 {
				;68	 	GET_KEY_BITMAP();
				_TouchFun:
				_TouchFun:
07BB	247F	call    L047F
				;69		if(DATA_BUF[0]==0x01)  
07BC	076B	mov     a, __pdpu[52]
07BD	40E3	mov     _TouchFun_2, a
07BE	5763	sdza    _TouchFun_2
07BF	2FC6	jmp     _L96
				;70		{
				;71			if(KeyRelease == KeyStatus)
07C0	50BE	sz      KeyStatus[0]
07C1	2FDB	jmp     _L95
				;72			{
				;73				KeyStatus = KeyPress;
07C2	0F01	mov     a, 1H
07C3	40BE	mov     KeyStatus[0], a
				;74				KeySwitchProcess()	;
07C4	2695	call    _KeySwitchProcess
07C5	2FDB	jmp     _L95
				;75			}			
				;76		}
				;77		else if(DATA_BUF[0]==0x08) 
				_L96:
07C6	4763	mov     a, _TouchFun_2
07C7	0A08	sub     a, 8H
07C8	390A	snz     Z
07C9	2FD0	jmp     _L98
				;78		{
				;79			if(KeyRelease == KeyStatus)
07CA	50BE	sz      KeyStatus[0]
07CB	2FDB	jmp     _L95
				;80			{
				;81				KeyStatus = KeyPress;
07CC	0F01	mov     a, 1H
07CD	40BE	mov     KeyStatus[0], a
				;82				KeyDownProcess();
07CE	2632	call    _KeyDownProcess
07CF	2FDB	jmp     _L95
				;83			}		
				;84		}
				;85		else if(DATA_BUF[0]==0x10)
				_L98:
07D0	4763	mov     a, _TouchFun_2
07D1	0A10	sub     a, 10H
07D2	390A	snz     Z
07D3	2FDA	jmp     _L99
				;86		{
				;87			if(KeyRelease == KeyStatus)
07D4	50BE	sz      KeyStatus[0]
07D5	2FDB	jmp     _L95
				;88			{
				;89				KeyStatus = KeyPress;
07D6	0F01	mov     a, 1H
07D7	40BE	mov     KeyStatus[0], a
				;90				KeyUpProcess()	;		
07D8	2662	call    _KeyUpProcess
07D9	2FDB	jmp     _L95
				;91			}
				;92		}		
				;93		else
				;94		{
				;95			KeyStatus = KeyRelease ;
				_L99:
07DA	5F3E	clr     KeyStatus[0]
				_L95:
07DB	0003	ret
				;96		}	
				;97	 }
				;98	//***********************************************************
				;99		
				;100	//	Adc
				;101	 
				;102	//***********************************************************
				;103	//查值 二分法
				;104	/**/ 
				;105	unsigned char TempValueSearch(unsigned short Res) 
				;106	{
				;107		volatile unsigned char low = 0, mid =0, high = 100;
				_TempValueSearch:
				_TempValueSearch:
07DC	5F61	clr     low[0]
07DD	5F60	clr     mid[0]
07DE	0F64	mov     a, 64H
07DF	40DF	mov     high[0], a
				;108		while(high - low >= 1)
				_L101:
07E0	4761	mov     a, low[0]
07E1	40D5	mov     rb, a
07E2	5F56	clr     rc
07E3	475F	mov     a, high[0]
07E4	42D5	subm    a, rb
07E5	1F05	clr     ACC
07E6	52D6	sbcm    a, rc
07E7	7FD6	sz      rc.7
07E8	6839	jmp     _L108
07E9	4755	mov     a, rb
07EA	4556	or      a, rc
07EB	3D0A	sz      Z
07EC	6839	jmp     _L108
				;109		{
				;110			mid = (low +high)/2;
07ED	4761	mov     a, low[0]
07EE	40D5	mov     rb, a
07EF	5F56	clr     rc
07F0	475F	mov     a, high[0]
07F1	43D5	addm    a, rb
07F2	3C0A	sz      C
07F3	54D6	inc     rc
07F4	5A56	rlca    rc
07F5	5BD6	rrc     rc
07F6	5BD5	rrc     rb
07F7	4755	mov     a, rb
07F8	40E0	mov     mid[0], a
				;111			if(Res <  TempForm[mid])
07F9	4760	mov     a, mid[0]
07FA	40D5	mov     rb, a
07FB	5F56	clr     rc
07FC	340A	clr     C
07FD	5AD5	rlc     rb
07FE	5AD6	rlc     rc
07FF	0F02	mov     a, 2H
0800	4355	add     a, rb
0801	0083	mov     MP1, a
0802	0F8A	mov     a, 8AH
0803	5356	adc     a, rc
0804	0081	mov     MP0, a
0805	63E1	call    L0BE1
0806	40D5	mov     rb, a
0807	63DE	call    L0BDE
0808	40D6	mov     rc, a
0809	475D	mov     a, Res[0]
080A	4255	sub     a, rb
080B	475E	mov     a, Res[1]
080C	5256	sbc     a, rc
080D	3C0A	sz      C
080E	6812	jmp     _L102
				;112			{
				;113				low = mid; //+1
080F	4760	mov     a, mid[0]
0810	40E1	mov     low[0], a
0811	682A	jmp     _L110
				;114				if(high -low<2)
				;115				{
				;116					return mid;
				;117				}
				;118			}
				;119			else if(Res >  TempForm[mid] )
				_L102:
0812	4760	mov     a, mid[0]
0813	40D5	mov     rb, a
0814	5F56	clr     rc
0815	340A	clr     C
0816	5AD5	rlc     rb
0817	5AD6	rlc     rc
0818	0F02	mov     a, 2H
0819	4355	add     a, rb
081A	0083	mov     MP1, a
081B	0F8A	mov     a, 8AH
081C	5356	adc     a, rc
081D	0081	mov     MP0, a
081E	63E1	call    L0BE1
081F	40D5	mov     rb, a
0820	63DE	call    L0BDE
0821	40D6	mov     rc, a
0822	4755	mov     a, rb
0823	425D	sub     a, Res[0]
0824	4756	mov     a, rc
0825	525E	sbc     a, Res[1]
0826	3C0A	sz      C
0827	6839	jmp     _L108
				;120			{
				;121				high = mid 	;//-1	
0828	4760	mov     a, mid[0]
0829	40DF	mov     high[0], a
				;122				if(high -low<2)
				_L110:
082A	4761	mov     a, low[0]
082B	40D5	mov     rb, a
082C	5F56	clr     rc
082D	475F	mov     a, high[0]
082E	42D5	subm    a, rb
082F	1F05	clr     ACC
0830	52D6	sbcm    a, rc
0831	0F01	mov     a, 1H
0832	4255	sub     a, rb
0833	0F00	mov     a, 0H
0834	5256	sbc     a, rc
0835	1185	swap    ACC
0836	040A	xor     a, STATUS
0837	3D85	sz      ACC.3
0838	2FE0	jmp     _L101
				;123				{
				;124					return mid;
				;125				}	
				;126			}
				;127			else
				;128			{
				;129				return mid;
				;130			}		
				;131		}
				;132	 	return mid;
				_L108:
0839	4760	mov     a, mid[0]
083A	40D4	mov     ra, a
				;133	 }
083B	4754	mov     a, ra
083C	0003	ret
				;134	void ADCGetFun(void)
				;135	{
				;136	    if(_eocb==0)//ad转换结束标记
				_ADCGetFun:
				_ADCGetFun:
083D	3F30	sz      EOCB
083E	68E4	jmp     _L111
				;137		{
				;138			dat = _adrh;        // 高8位AD转换 
083F	072F	mov     a, ADRH
0840	409C	mov     dat[0], a
0841	5F1D	clr     dat[1]
				;139			dat <<=4;
0842	0F04	mov     a, 4H
				_LI3:
0843	340A	clr     C
0844	5A9C	rlc     dat[0]
0845	5A9D	rlc     dat[1]
0846	1785	sdz     ACC
0847	6843	jmp     _LI3
				;140			dat += (_adrl>>4);  	 		      	  
0848	112E	swapa   ADRL
0849	0E0F	and     a, FH
084A	40D5	mov     rb, a
084B	5F56	clr     rc
084C	4755	mov     a, rb
084D	439C	addm    a, dat[0]
084E	4756	mov     a, rc
084F	539D	adcm    a, dat[1]
				;141	      	  
				;142			intTemp1 = (4095 - dat);//串联电阻20K
0850	0FFF	mov     a, FFH
0851	421C	sub     a, dat[0]
0852	40D4	mov     ra, a
0853	0F0F	mov     a, FH
0854	521D	sbc     a, dat[1]
0855	40D5	mov     rb, a
0856	4754	mov     a, ra
0857	408B	mov     intTemp1[0], a
0858	4755	mov     a, rb
0859	408C	mov     intTemp1[1], a
				;143			//longTemp1	= 200UL * dat ;
				;144			
				;145			R_value	= 200UL* dat/intTemp1;
085A	471C	mov     a, dat[0]
085B	40D7	mov     rd, a
085C	471D	mov     a, dat[1]
085D	40D8	mov     re, a
085E	5F59	clr     rf
085F	5F5A	clr     rg
0860	4757	mov     a, rd
0861	40DD	mov     Res, a
0862	4758	mov     a, re
0863	40DE	mov     _DataSave_2, a
0864	4759	mov     a, rf
0865	40DF	mov     high, a
0866	475A	mov     a, rg
0867	40E0	mov     mid, a
0868	0FC8	mov     a, C8H
0869	40E1	mov     _SunControl_2, a
086A	0F00	mov     a, 0H
086B	40E2	mov     _SunControl_2[1], a
086C	0F00	mov     a, 0H
086D	40E3	mov     _TouchFun_2, a
086E	0F00	mov     a, 0H
086F	40E4	mov     _TouchFun_2[1], a
0870	6363	call    L0B63
0871	4765	mov     a, _TouchFun_2[2]
0872	40D7	mov     rd, a
0873	4766	mov     a, _TouchFun_2[3]
0874	40D8	mov     re, a
0875	4767	mov     a, _TouchFun_2[4]
0876	40D9	mov     rf, a
0877	4768	mov     a, _TouchFun_2[5]
0878	40DA	mov     rg, a
0879	5F69	clr     _TouchFun_2[6]
087A	4757	mov     a, rd
087B	40DD	mov     Res, a
087C	4758	mov     a, re
087D	40DE	mov     _DataSave_2, a
087E	4759	mov     a, rf
087F	40DF	mov     high, a
0880	475A	mov     a, rg
0881	40E0	mov     mid, a
0882	470B	mov     a, intTemp1[0]
0883	40E1	mov     _SunControl_2, a
0884	470C	mov     a, intTemp1[1]
0885	40E2	mov     _SunControl_2[1], a
0886	5F63	clr     _TouchFun_2
0887	5F64	clr     _TouchFun_2[1]
0888	6382	call    L0B82
0889	475D	mov     a, Res
088A	4094	mov     R_value[0], a
088B	475E	mov     a, _DataSave_2
088C	4095	mov     R_value[1], a
088D	475F	mov     a, high
088E	4096	mov     R_value[2], a
088F	4760	mov     a, mid
0890	4097	mov     R_value[3], a
				;146			if(R_value < 20) R_value = 1750;//初始检测，无值认为是0
0891	0F13	mov     a, 13H
0892	4214	sub     a, R_value[0]
0893	0F00	mov     a, 0H
0894	5215	sbc     a, R_value[1]
0895	0F00	mov     a, 0H
0896	5216	sbc     a, R_value[2]
0897	0F00	mov     a, 0H
0898	5217	sbc     a, R_value[3]
0899	380A	snz     C
089A	68A1	jmp     _L113
089B	0FD6	mov     a, D6H
089C	4094	mov     R_value[0], a
089D	0F06	mov     a, 6H
089E	4095	mov     R_value[1], a
089F	5F16	clr     R_value[2]
08A0	5F17	clr     R_value[3]
				;147			
				;148			R_valueSum = R_valueSum + R_value ;
				_L113:
08A1	4714	mov     a, R_value[0]
08A2	4390	addm    a, R_valueSum[0]
08A3	4715	mov     a, R_value[1]
08A4	5391	adcm    a, R_valueSum[1]
08A5	4716	mov     a, R_value[2]
08A6	5392	adcm    a, R_valueSum[2]
08A7	4717	mov     a, R_value[3]
08A8	5393	adcm    a, R_valueSum[3]
				;149			ADCCount ++;
08A9	548E	inc     ADCCount[0]
08AA	3D0A	sz      Z
08AB	548F	inc     ADCCount[1]
				;150			if(100 == ADCCount)
08AC	470E	mov     a, ADCCount[0]
08AD	0C64	xor     a, 64H
08AE	450F	or      a, ADCCount[1]
08AF	390A	snz     Z
08B0	68E1	jmp     _L114
				;151			{
				;152				R_value 		= R_valueSum/100;
08B1	5F69	clr     _TouchFun_2[6]
08B2	4710	mov     a, R_valueSum[0]
08B3	40DD	mov     Res, a
08B4	4711	mov     a, R_valueSum[1]
08B5	40DE	mov     _DataSave_2, a
08B6	4712	mov     a, R_valueSum[2]
08B7	40DF	mov     high, a
08B8	4713	mov     a, R_valueSum[3]
08B9	40E0	mov     mid, a
08BA	0F64	mov     a, 64H
08BB	40E1	mov     _SunControl_2, a
08BC	0F00	mov     a, 0H
08BD	40E2	mov     _SunControl_2[1], a
08BE	5F63	clr     _TouchFun_2
08BF	5F64	clr     _TouchFun_2[1]
08C0	6382	call    L0B82
08C1	475D	mov     a, Res
08C2	4094	mov     R_value[0], a
08C3	475E	mov     a, _DataSave_2
08C4	4095	mov     R_value[1], a
08C5	475F	mov     a, high
08C6	4096	mov     R_value[2], a
08C7	4760	mov     a, mid
08C8	4097	mov     R_value[3], a
				;153				T_valueGet 		= TempValueSearch(R_value);
08C9	4714	mov     a, R_value[0]
08CA	40D7	mov     rd, a
08CB	4715	mov     a, R_value[1]
08CC	40D8	mov     re, a
08CD	4716	mov     a, R_value[2]
08CE	40D9	mov     rf, a
08CF	4717	mov     a, R_value[3]
08D0	40DA	mov     rg, a
08D1	4757	mov     a, rd
08D2	40DD	mov     Res, a
08D3	4758	mov     a, re
08D4	40DE	mov     _DataSave_2, a
08D5	27DC	call    _TempValueSearch
08D6	40D4	mov     ra, a
08D7	4754	mov     a, ra
08D8	409E	mov     T_valueGet[0], a
				;154						
				;155				ADCCount 		= 0;
08D9	5F0E	clr     ADCCount[0]
08DA	5F0F	clr     ADCCount[1]
				;156				R_valueSum 		= 0;
08DB	5F10	clr     R_valueSum[0]
08DC	5F11	clr     R_valueSum[1]
08DD	5F12	clr     R_valueSum[2]
08DE	5F13	clr     R_valueSum[3]
				;157				ADCCompleteFlag = 1;
08DF	0F01	mov     a, 1H
08E0	408D	mov     ADCCompleteFlag[0], a
				;158			}
				;159			_start=0;//0 → 1 → 0： 启动
				_L114:
08E1	37B0	clr     START
				;160			_start=1;
08E2	33B0	set     START
				;161			_start=0; 
08E3	37B0	clr     START
				_L111:
08E4	0003	ret
				;162		} 
				;163	}    
				;164	void ErrorProcess(void)
				;165	{
				;166		unsigned char i;
				;167		RelayHeatClose;	// Heat Close ; PV Open
				_ErrorProcess:
				_ErrorProcess:
08E5	3414	clr     PA0
				;168		RelayPVClose;
08E6	3114	set     PA2
				;169		TimerClose;//定时器 关闭		
08E7	361D	clr     TON
08E8	0F0A	mov     a, AH
08E9	40E1	mov     _SunControl_2, a
				;170		for(i = 0;i<10;i++ )//蜂鸣器报警10声	
				;171		{
				;172			Beep1 =  BeepOpen;
				_L117:
08EA	3194	set     PA3
				;173			delay();
08EB	2799	call    _delay
				;174			delay();
08EC	2799	call    _delay
				;175			Beep1 =  BeepClose;
08ED	3594	clr     PA3
				;176			delay();			
08EE	2799	call    _delay
08EF	57E1	sdz     _SunControl_2
08F0	68EA	jmp     _L117
08F1	0003	ret
				;177			//喂狗
				;178		}
				;179	}
				;180	unsigned char ADC_Check(void)
				;181	{	
				;182		// unsigned char i;
				;183	
				;184		if((T_valueGet < 3)&&(0 == E2WaringFlag)&&(1!= E1WaringFlag))
				_ADC_Check:
				_ADC_Check:
0A0B	0F02	mov     a, 2H
0A0C	421E	sub     a, T_valueGet[0]
0A0D	380A	snz     C
0A0E	6A1E	jmp     _L143
0A0F	50A0	sz      E2WaringFlag[0]
0A10	6A1E	jmp     _L143
0A11	571F	sdza    E1WaringFlag[0]
0A12	6A14	jmp     _LI4
0A13	6A1E	jmp     _L143
				;185		{
				;186			E2WaringFlag = 1;//报警标记
				_LI4:
0A14	0F01	mov     a, 1H
0A15	40A0	mov     E2WaringFlag[0], a
				;187			D_E2;//显示“E2”				
0A16	5F4B	clr     C_Display[0]
0A17	0F0E	mov     a, EH
0A18	40DF	mov     high, a
0A19	0FC0	mov     a, C0H
0A1A	25A5	call    _display16
0A1B	0F02	mov     a, 2H
0A1C	40DF	mov     high, a
0A1D	6A30	jmp     _L154
				;188			ErrorProcess();
				;189			return 0;
				;190		}	
				;191		else if(( T_valueGet > 98)&&(0 == E1WaringFlag)&&(1 != E2WaringFlag))
				_L143:
0A1E	0F62	mov     a, 62H
0A1F	421E	sub     a, T_valueGet[0]
0A20	3C0A	sz      C
0A21	6A38	jmp     _L145
0A22	509F	sz      E1WaringFlag[0]
0A23	6A38	jmp     _L145
0A24	5720	sdza    E2WaringFlag[0]
0A25	6A27	jmp     _LI5
0A26	6A38	jmp     _L145
				;192		{
				;193			E1WaringFlag = 1;
				_LI5:
0A27	0F01	mov     a, 1H
0A28	409F	mov     E1WaringFlag[0], a
				;194			D_E1;//显示“E1”	
0A29	5F4B	clr     C_Display[0]
0A2A	0F0E	mov     a, EH
0A2B	40DF	mov     high, a
0A2C	0FC0	mov     a, C0H
0A2D	25A5	call    _display16
0A2E	0F01	mov     a, 1H
0A2F	40DF	mov     high, a
				_L154:
0A30	0FC4	mov     a, C4H
0A31	25A5	call    _display16
0A32	0F10	mov     a, 10H
0A33	40DF	mov     high, a
0A34	0FCC	mov     a, CCH
0A35	25A5	call    _display16
				;195			ErrorProcess();
0A36	60E5	call    _ErrorProcess
0A37	6A45	jmp     _L147
				;196			return 0;
				;197		}
				;198		if((1 == E2WaringFlag)||(1 == E2WaringFlag))
				_L145:
0A38	4720	mov     a, E2WaringFlag[0]
0A39	0A01	sub     a, 1H
0A3A	3D0A	sz      Z
0A3B	6A45	jmp     _L147
0A3C	0A00	sub     a, 0H
0A3D	3D0A	sz      Z
0A3E	6A45	jmp     _L147
				;199		{
				;200			return 0;
				_L147:
0A45	5F54	clr     ra
				;201		}
				;202		else
				;203		{	
				;204			E1WaringFlag = E2WaringFlag = 0;	//报警标记 Clear 
0A3F	5F20	clr     E2WaringFlag[0]
0A40	5F1F	clr     E1WaringFlag[0]
				;205			//工作状态检查，是否是空闲
				;206			SunControl();
0A41	6147	call    _SunControl
				;207			return 1;
0A42	0F01	mov     a, 1H
0A43	40D4	mov     ra, a
0A44	6A46	jmp     _L144
				;208		}	
				;209	}
				_L144:
0A46	4754	mov     a, ra
0A47	0003	ret
				;210	
				;211	//***********************************************************
				;212	//*SUB. NAME:USER INITIAL PROGRAM                           *
				;213	//*INPUT    :                                               *
				;214	//*OUTPUT   :                                               *
				;215	//*USED REG.:                                               *
				;216	//*FUNCTION :                                               *
				;217	//***********************************************************
				;218	void LEDX4_V16_INITIAL()
				;219	{
				;220	//LED BEEP INITIAL
				;221	//LED 	0 	打开
				;222	//Beep 	0 	关闭
				;223		LEDSwitch_C = 0;
				_LEDX4_V16_INITIAL:
				_LEDX4_V16_INITIAL:
08F2	3495	clr     PAC1
				;224		LEDSwitch	= LedOpen;//Open
08F3	3494	clr     PA1
				;225	  	LED_DOWN_C	= 0;
08F4	3521	clr     PBC2
				;226		LED_DOWN  	= LedOpen;
08F5	3520	clr     PB2
				;227	 	LED_UP_C 	= 0;
08F6	34A1	clr     PBC1
				;228	 	LED_UP  	= LedOpen;
08F7	34A0	clr     PB1
				;229	 	Beep1_C = 0;//Close
08F8	3595	clr     PAC3
				;230	 	Beep1   = BeepOpen; 
08F9	3194	set     PA3
				;231	// Relay 
				;232		Relay_HEAT_C  	=  0;
08FA	3415	clr     PAC0
				;233		RelayHeatClose;
08FB	3414	clr     PA0
				;234		Relay_PV_C 		=  0;
08FC	3515	clr     PAC2
				;235		RelayPVOpen;
08FD	3514	clr     PA2
				;236	//数码管引脚初始化
				;237		CLK1_C	= 0;
08FE	3795	clr     PAC7
				;238		CLK1	= 0;
08FF	3794	clr     PA7
				;239		DIO1_C	= 0;
0900	3615	clr     PAC4
				;240		DIO1	= 0;
0901	3614	clr     PA4
				;241		STB1_C	= 0;//
0902	34B6	clr     PDC1
				;242		STB1	= 0;
0903	34B5	clr     PD1
				;243	//人体感应
				;244		_pdpu7	= 1;	
0904	33B7	set     PDPU7
				;245		_pdc7 	= 1;//		 
0905	33B6	set     PDC7
				;246		_pd7 	= 0;		
0906	37B5	clr     PD7
				;247	//红外引脚初始化
				;248		_pbpu5  =  1;  //设置上拉电阻
0907	32A2	set     PBPU5
				;249		_pbc5   =  1;	//设置为输入
0908	32A1	set     PBC5
				;250		_pbpu4  =  1;  //设置上拉电阻
0909	3222	set     PBPU4
				;251		_pbpu7  =  1;  //设置上拉电阻
090A	33A2	set     PBPU7
				;252		// _pdpu0  =  1;
				;253	//adc 初始化	
				;254		 _adcr0=0b00000000;   // 选择 A/D 通道AN0--Pd0   
090B	1F30	clr     ADCR0
				;255		 _adcr1=0b00000100;   // 定义 ADC 时钟源=Fsys/16
090C	0F04	mov     a, 4H
090D	00B1	mov     ADCR1, a
				;256		 _acerl=0b00000001;   // 定义 Pd0 为 A/D 输入AN0		
090E	0F01	mov     a, 1H
090F	00B2	mov     ACERL, a
				;257		
				;258		_start=0;
0910	37B0	clr     START
				;259		_start=1;
0911	33B0	set     START
				;260		_start=0;
0912	37B0	clr     START
				;261	//变量initial	
				;262		
				;263	//Time初始化
				;264		timerInit();
0913	27B3	call    _timerInit
				;265		//A 接通电源 蜂鸣器短鸣一声，数码屏所有灯点亮二秒
				;266		delay()	;
0914	2799	call    _delay
				;267		Beep1 = BeepClose;
0915	3594	clr     PA3
				;268		//数码管All Open
				;269		displayClear(0xffff);
0916	5FDF	set     high
0917	5FE0	set     mid
0918	2592	call    _displayClear
				;270		// displayTwst(0xc0,0xffff); 
				;271		delay()	;	
0919	2799	call    _delay
				;272		delay()	;
091A	2799	call    _delay
				;273		delay()	;	
091B	2799	call    _delay
				;274		delay()	;	
091C	2799	call    _delay
				;275		//数码管显示清零	
				;276		displayClear(0);
091D	5F5F	clr     high
091E	5F60	clr     mid
091F	2592	call    _displayClear
				;277		C_Display = 0x70;
0920	0F70	mov     a, 70H
0921	40CB	mov     C_Display[0], a
				;278		Temp_Num1_L	= 5 ;
0922	0F05	mov     a, 5H
0923	40C2	mov     Temp_Num1_L[0], a
				;279		Temp_Num1_H	= 8 ;
0924	0F08	mov     a, 8H
0925	40C1	mov     Temp_Num1_H[0], a
				;280		//默认设置温度为85℃
				;281		//显示屏显示内胆当前温度	
				;282		LEDSwitch = LED_DOWN = LED_UP = LedClose;	
0926	30A0	set     PB1
0927	3120	set     PB2
0928	3094	set     PA1
				;283		//
				;284		NoneFlag = 0;
0929	5F2C	clr     NoneFlag[0]
092A	0003	ret
				;285	}
				;286	void HeatCompleteBeep(void)
				;287	{
				;288		if(timerCount > 900000 - 300)//计时
				_HeatCompleteBeep:
				_HeatCompleteBeep:
092B	0F74	mov     a, 74H
092C	4236	sub     a, timerCount[0]
092D	0FBA	mov     a, BAH
092E	5237	sbc     a, timerCount[1]
092F	0F0D	mov     a, DH
0930	5238	sbc     a, timerCount[2]
0931	0F00	mov     a, 0H
0932	5239	sbc     a, timerCount[3]
0933	3C0A	sz      C
0934	693A	jmp     _L119
				;289		{
				;290			Beep1 = BeepOpen;
0935	3194	set     PA3
				;291			KeyCountOpenflag = 1;
0936	0F01	mov     a, 1H
0937	40CF	mov     KeyCountOpenflag[0], a
				;292			ControlFlag = StatusSwitchOFF;//进入加热结束状态	//
0938	0F02	mov     a, 2H
0939	408A	mov     ControlFlag[0], a
				_L119:
093A	0003	ret
				;293		}	
				;294	}
				;295	void PersonCheckDisableFun(void)//红外检测失效处理
				;296	{
				;297		if((1 == PersonCheck))//有人
				_PersonCheckDisableFun:
				_PersonCheckDisableFun:
093B	3BB5	snz     PD7
093C	6940	jmp     _L122
				;298		{
				;299			ND_Heat();RelayHeatClose;//电磁阀关闭
093D	5F4C	clr     CaValue[0]
093E	3414	clr     PA0
093F	6946	jmp     _L121
				;300			// ND_PV();RelayPVClose;
				;301		}
				;302		else
				;303		{	
				;304			D_Heat();RelayHeatOpen;//电磁阀打开
				_L122:
0940	0F10	mov     a, 10H
0941	40CC	mov     CaValue[0], a
0942	3014	set     PA0
				;305			D_PV();RelayPVOpen;		
0943	0F10	mov     a, 10H
0944	40CE	mov     C8Value[0], a
0945	3514	clr     PA2
				_L121:
0946	0003	ret
				;306		}					
				;307	}
				;308	
				;309	void SunControl(void)
				;310	{	
				;311		switch(ControlFlag)
				_SunControl:
				_SunControl:
0947	470A	mov     a, ControlFlag[0]
0948	40E1	mov     _SunControl_2, a
0949	4761	mov     a, _SunControl_2
094A	0A00	sub     a, 0H
094B	3D0A	sz      Z
094C	695C	jmp     _L126
094D	0A01	sub     a, 1H
094E	3D0A	sz      Z
094F	697B	jmp     _L127
0950	4761	mov     a, _SunControl_2
0951	0A02	sub     a, 2H
0952	3D0A	sz      Z
0953	699A	jmp     _L128
0954	0A01	sub     a, 1H
0955	3D0A	sz      Z
0956	69A7	jmp     _L129
0957	4761	mov     a, _SunControl_2
0958	0A05	sub     a, 5H
0959	390A	snz     Z
095A	6A0A	jmp     _L124
095B	69DF	jmp     _L141
				;312		{
				;313			case StatusIdle:
				;314				if(T_valueGet  < 30)//内胆温度低于35℃,自动加热，是否有其他开启条件
				_L126:
095C	0F1D	mov     a, 1DH
095D	421E	sub     a, T_valueGet[0]
095E	380A	snz     C
095F	6962	jmp     _L131
				;315				{
				;316					PersonCheckDisableFun();
0960	613B	call    _PersonCheckDisableFun
0961	6A0A	jmp     _L124
				;317				}
				;318				else if(T_valueGet  < 35)
				_L131:
0962	0F22	mov     a, 22H
0963	421E	sub     a, T_valueGet[0]
0964	380A	snz     C
0965	696A	jmp     _L132
				;319				{
				;320					D_PV();RelayPVOpen;
0966	0F10	mov     a, 10H
0967	40CE	mov     C8Value[0], a
0968	3514	clr     PA2
0969	6A0A	jmp     _L124
				;321				}
				;322				else if(T_valueGet < 80)
				_L132:
096A	0F4F	mov     a, 4FH
096B	421E	sub     a, T_valueGet[0]
096C	380A	snz     C
096D	6972	jmp     _L133
				;323				{
				;324					// if((1 == PersonCheck))//有人
				;325					// {
				;326						// ND_PV();RelayPVClose;
				;327					// }
				;328					// else
				;329					// {	
				;330						D_PV();RelayPVOpen;
096E	0F10	mov     a, 10H
096F	40CE	mov     C8Value[0], a
0970	3514	clr     PA2
0971	6978	jmp     _L140
				;331					// }
				;332					ND_Heat();RelayHeatClose;//电磁阀关闭
				;333				
				;334				}
				;335				else if(T_valueGet <85)
				_L133:
0972	0F54	mov     a, 54H
0973	421E	sub     a, T_valueGet[0]
0974	3C0A	sz      C
0975	6A0A	jmp     _L124
				;336				{
				;337					
				;338				}
				;339				else
				;340				{
				;341					ND_PV();RelayPVClose;
0976	5F4E	clr     C8Value[0]
0977	3114	set     PA2
				;342					ND_Heat();RelayHeatClose;
				_L140:
0978	5F4C	clr     CaValue[0]
0979	3414	clr     PA0
097A	6A0A	jmp     _L124
				;343				}	
				;344			break;
				;345			case StatusSwitchON:
				;346				if(Close == timer3sFlag)
				_L127:
097B	50B4	sz      timer3sFlag[0]
097C	698A	jmp     _L135
				;347				{
				;348					if((Close == timerFlag)&&(KeyRelease == KeyStatus  ))
097D	50B5	sz      timerFlag[0]
097E	698A	jmp     _L135
097F	50BE	sz      KeyStatus[0]
0980	698A	jmp     _L135
				;349					{
				;350						TimerSetFun(2000);	
0981	0FD0	mov     a, D0H
0982	40DD	mov     Res, a
0983	0F07	mov     a, 7H
0984	40DE	mov     _DataSave_2, a
0985	5F5F	clr     high
0986	5F60	clr     mid
0987	2788	call    _TimerSetFun
				;351						timer3sFlag = Open;
0988	0F01	mov     a, 1H
0989	40B4	mov     timer3sFlag[0], a
				;352					}
				;353				}
				;354				if(timerCount > 1800)
				_L135:
098A	0F08	mov     a, 8H
098B	4236	sub     a, timerCount[0]
098C	0F07	mov     a, 7H
098D	5237	sbc     a, timerCount[1]
098E	0F00	mov     a, 0H
098F	5238	sbc     a, timerCount[2]
0990	0F00	mov     a, 0H
0991	5239	sbc     a, timerCount[3]
0992	3C0A	sz      C
0993	6A0A	jmp     _L124
				;355				{
				;356					Beep1 = BeepOpen;
0994	3194	set     PA3
				;357					KeyCountOpenflag = 1;
0995	0F01	mov     a, 1H
0996	40CF	mov     KeyCountOpenflag[0], a
				;358					ControlFlag = StatusHeatOpen;//进入加热状态
0997	0F03	mov     a, 3H
0998	408A	mov     ControlFlag[0], a
0999	6A0A	jmp     _L124
				;359				}
				;360			break;
				;361			case StatusSwitchOFF: //StatusHeatComplete
				;362				KeySwitchStatus = KeySitchOFF;	
				_L128:
099A	5F51	clr     KeySwitchStatus[0]
				;363				LEDSwitch = LedClose;
099B	3094	set     PA1
				;364				
				;365				timer1hourFlag = timer3sFlag = timerFlag = Close;	
099C	5F35	clr     timerFlag[0]
099D	5F34	clr     timer3sFlag[0]
099E	5F33	clr     timer1hourFlag[0]
				;366				timerCount = 0;
099F	5F36	clr     timerCount[0]
09A0	5F37	clr     timerCount[1]
09A1	5F38	clr     timerCount[2]
09A2	5F39	clr     timerCount[3]
				;367				
				;368				TimerClose;		
09A3	361D	clr     TON
				;369				//RelayHeatClose;//加热关闭
				;370				//ND_Heat();//关闭加热显示
				;371				ND_WarmKeep();//关闭保温显示
09A4	5F4D	clr     C8Value2[0]
				;372				ControlFlag = StatusIdle;	
09A5	5F0A	clr     ControlFlag[0]
				;373	//			KeyFirstPressFlag = 0;
				;374			break;
09A6	6A0A	jmp     _L124
				;375			case StatusHeatOpen:
				;376	//			KeyFirstPressFlag = 0;	
				;377				
				;378				if(Close == timerFlag)//定时器空闲
				_L129:
09A7	50B5	sz      timerFlag[0]
09A8	69B5	jmp     _L137
				;379				{
				;380					if(Close == timer1hourFlag)
09A9	50B3	sz      timer1hourFlag[0]
09AA	69B5	jmp     _L137
				;381					{
				;382						timer1hourFlag = Open;
09AB	0F01	mov     a, 1H
09AC	40B3	mov     timer1hourFlag[0], a
				;383						TimerSetFun(900000);//30000	1h 1800000
09AD	0FA0	mov     a, A0H
09AE	40DD	mov     Res, a
09AF	0FBB	mov     a, BBH
09B0	40DE	mov     _DataSave_2, a
09B1	0F0D	mov     a, DH
09B2	40DF	mov     high, a
09B3	5F60	clr     mid
09B4	2788	call    _TimerSetFun
				;384					}
				;385					//开始
				;386				}
				;387				if(T_valueGet > Temp_Num1)//ADC 加滤波
				_L137:
09B5	471E	mov     a, T_valueGet[0]
09B6	40D7	mov     rd, a
09B7	5F58	clr     re
09B8	4741	mov     a, Temp_Num1_H[0]
09B9	40D5	mov     rb, a
09BA	5F56	clr     rc
09BB	340A	clr     C
09BC	5A55	rlca    rb
09BD	40D9	mov     rf, a
09BE	5A56	rlca    rc
09BF	40DA	mov     rg, a
09C0	340A	clr     C
09C1	5AD9	rlc     rf
09C2	5ADA	rlc     rg
09C3	4759	mov     a, rf
09C4	43D5	addm    a, rb
09C5	475A	mov     a, rg
09C6	53D6	adcm    a, rc
09C7	340A	clr     C
09C8	5AD5	rlc     rb
09C9	5AD6	rlc     rc
09CA	4742	mov     a, Temp_Num1_L[0]
09CB	43D5	addm    a, rb
09CC	3C0A	sz      C
09CD	54D6	inc     rc
09CE	4755	mov     a, rb
09CF	4257	sub     a, rd
09D0	4756	mov     a, rc
09D1	5258	sbc     a, re
09D2	1185	swap    ACC
09D3	040A	xor     a, STATUS
09D4	3985	snz     ACC.3
09D5	69DD	jmp     _L138
				;388				{
				;389					// ND_PV();RelayPVClose;
				;390					ND_Heat();RelayHeatClose;//关闭加热 
09D6	5F4C	clr     CaValue[0]
09D7	3414	clr     PA0
				;391					
				;392					D_WarmKeep();
09D8	0F20	mov     a, 20H
09D9	40CD	mov     C8Value2[0], a
				;393					ControlFlag = StatusWarmHold;//进入温度保持	
09DA	0F05	mov     a, 5H
09DB	408A	mov     ControlFlag[0], a
09DC	6A0A	jmp     _L124
				;394				}
				;395				else
				;396				{					
				;397					PersonCheckDisableFun();
				_L138:
09DD	613B	call    _PersonCheckDisableFun
09DE	6A09	jmp     _L139
				;398					HeatCompleteBeep();
				;399				}	
				;400			break;
				;401			case StatusWarmHold:
				;402	//			KeyFirstPressFlag = 0;			
				;403				if(T_valueGet < Temp_Num1-5)//ADC 加滤波
				_L141:
09DF	471E	mov     a, T_valueGet[0]
09E0	40E1	mov     _SunControl_2, a
09E1	5F62	clr     _SunControl_2[1]
09E2	0FFB	mov     a, FBH
09E3	4342	add     a, Temp_Num1_L[0]
09E4	40D7	mov     rd, a
09E5	0FFF	mov     a, FFH
09E6	5F58	clr     re
09E7	53D8	adcm    a, re
09E8	4741	mov     a, Temp_Num1_H[0]
09E9	40D5	mov     rb, a
09EA	5F56	clr     rc
09EB	340A	clr     C
09EC	5A55	rlca    rb
09ED	40D9	mov     rf, a
09EE	5A56	rlca    rc
09EF	40DA	mov     rg, a
09F0	340A	clr     C
09F1	5AD9	rlc     rf
09F2	5ADA	rlc     rg
09F3	4759	mov     a, rf
09F4	43D5	addm    a, rb
09F5	475A	mov     a, rg
09F6	53D6	adcm    a, rc
09F7	340A	clr     C
09F8	5AD5	rlc     rb
09F9	5AD6	rlc     rc
09FA	4755	mov     a, rb
09FB	43D7	addm    a, rd
09FC	4756	mov     a, rc
09FD	53D8	adcm    a, re
09FE	4761	mov     a, _SunControl_2
09FF	4257	sub     a, rd
0A00	4762	mov     a, _SunControl_2[1]
0A01	5258	sbc     a, re
0A02	1185	swap    ACC
0A03	040A	xor     a, STATUS
0A04	3985	snz     ACC.3
0A05	6A09	jmp     _L139
				;404				{
				;405					ND_WarmKeep();
0A06	5F4D	clr     C8Value2[0]
				;406					ControlFlag = StatusHeatOpen;//进入加热状态	
0A07	0F03	mov     a, 3H
0A08	408A	mov     ControlFlag[0], a
				;407				}
				;408				HeatCompleteBeep();	
				_L139:
0A09	612B	call    _HeatCompleteBeep
				_L124:
0A0A	0003	ret
				;409			break;
				;410			default: break;
				;411		}
				;412	}
				;413	//屏幕显示
				;414	void ScreenDisplay(void)
				;415	{
				;416		BarTimerCount ++;
				_ScreenDisplay:
				_ScreenDisplay:
0A48	54C7	inc     BarTimerCount[0]
0A49	3D0A	sz      Z
0A4A	54C8	inc     BarTimerCount[1]
				;417		if(BarTimerCount>250)
0A4B	0FFA	mov     a, FAH
0A4C	4247	sub     a, BarTimerCount[0]
0A4D	0F00	mov     a, 0H
0A4E	5248	sbc     a, BarTimerCount[1]
0A4F	3C0A	sz      C
0A50	6AB6	jmp     _L155
				;418		{
				;419			if(BarNum >10)
0A51	0F0A	mov     a, AH
0A52	4249	sub     a, BarNum[0]
0A53	3C0A	sz      C
0A54	6A5A	jmp     _L157
				;420			{
				;421				BarDisplayNum1 = BarDisplayNum2 = BarDisplayNum3 = BarDisplayNum4 = 0;				
0A55	5F43	clr     BarDisplayNum4[0]
0A56	5F44	clr     BarDisplayNum3[0]
0A57	5F45	clr     BarDisplayNum2[0]
0A58	5F46	clr     BarDisplayNum1[0]
				;422				BarNum = 0;
0A59	5F49	clr     BarNum[0]
				;423			}
				;424			if(StatusHeatOpen == ControlFlag)
				_L157:
0A5A	470A	mov     a, ControlFlag[0]
0A5B	0A03	sub     a, 3H
0A5C	3D0A	sz      Z
0A5D	6A62	jmp     _L158
				;425			{
				;426			}
				;427			else
				;428			{
				;429				BarDisplayNum1 = BarDisplayNum2 = BarDisplayNum3 =	BarDisplayNum4 = 0;			
0A5E	5F43	clr     BarDisplayNum4[0]
0A5F	5F44	clr     BarDisplayNum3[0]
0A60	5F45	clr     BarDisplayNum2[0]
0A61	5F46	clr     BarDisplayNum1[0]
				;430			}	
				;431			if(BarNum == 0)				BarDisplayNum1 = BarDisplayNum1 + 0x10;			
				_L158:
0A62	50C9	sz      BarNum[0]
0A63	6A67	jmp     _L159
0A64	0F10	mov     a, 10H
0A65	43C6	addm    a, BarDisplayNum1[0]
0A66	6AA3	jmp     _L160
				;432			else if(BarNum == 1)		BarDisplayNum1 = BarDisplayNum1 + 0x20;			
				_L159:
0A67	5749	sdza    BarNum[0]
0A68	6A6C	jmp     _L161
0A69	0F20	mov     a, 20H
0A6A	43C6	addm    a, BarDisplayNum1[0]
0A6B	6AA3	jmp     _L160
				;433			else if(BarNum == 2)		BarDisplayNum1 = BarDisplayNum1 + 0x40;			
				_L161:
0A6C	4749	mov     a, BarNum[0]
0A6D	0A02	sub     a, 2H
0A6E	390A	snz     Z
0A6F	6A73	jmp     _L162
0A70	0F40	mov     a, 40H
0A71	43C6	addm    a, BarDisplayNum1[0]
0A72	6AA3	jmp     _L160
				;434			else if(BarNum == 3)		BarDisplayNum2 = BarDisplayNum2 + 0x10;			
				_L162:
0A73	4749	mov     a, BarNum[0]
0A74	0A03	sub     a, 3H
0A75	390A	snz     Z
0A76	6A7A	jmp     _L163
0A77	0F10	mov     a, 10H
0A78	43C5	addm    a, BarDisplayNum2[0]
0A79	6AA3	jmp     _L160
				;435			else if(BarNum == 4)		BarDisplayNum2 = BarDisplayNum2 + 0x20;			
				_L163:
0A7A	4749	mov     a, BarNum[0]
0A7B	0A04	sub     a, 4H
0A7C	390A	snz     Z
0A7D	6A81	jmp     _L164
0A7E	0F20	mov     a, 20H
0A7F	43C5	addm    a, BarDisplayNum2[0]
0A80	6AA3	jmp     _L160
				;436			else if(BarNum == 5)		BarDisplayNum2 = BarDisplayNum2 + 0x40;			
				_L164:
0A81	4749	mov     a, BarNum[0]
0A82	0A05	sub     a, 5H
0A83	390A	snz     Z
0A84	6A88	jmp     _L165
0A85	0F40	mov     a, 40H
0A86	43C5	addm    a, BarDisplayNum2[0]
0A87	6AA3	jmp     _L160
				;437			else if(BarNum == 6)		BarDisplayNum3 = BarDisplayNum3 + 0x10;			
				_L165:
0A88	4749	mov     a, BarNum[0]
0A89	0A06	sub     a, 6H
0A8A	390A	snz     Z
0A8B	6A8F	jmp     _L166
0A8C	0F10	mov     a, 10H
0A8D	43C4	addm    a, BarDisplayNum3[0]
0A8E	6AA3	jmp     _L160
				;438			else if(BarNum == 7)		BarDisplayNum3 = BarDisplayNum3 + 0x20;			
				_L166:
0A8F	4749	mov     a, BarNum[0]
0A90	0A07	sub     a, 7H
0A91	390A	snz     Z
0A92	6A96	jmp     _L167
0A93	0F20	mov     a, 20H
0A94	43C4	addm    a, BarDisplayNum3[0]
0A95	6AA3	jmp     _L160
				;439			else if(BarNum == 8)		BarDisplayNum3 = BarDisplayNum3 + 0x40; 	
				_L167:
0A96	4749	mov     a, BarNum[0]
0A97	0A08	sub     a, 8H
0A98	390A	snz     Z
0A99	6A9D	jmp     _L168
0A9A	0F40	mov     a, 40H
0A9B	43C4	addm    a, BarDisplayNum3[0]
0A9C	6AA3	jmp     _L160
				;440			else if(BarNum == 9)		BarDisplayNum4 = BarDisplayNum4 + 0x40; 		
				_L168:
0A9D	4749	mov     a, BarNum[0]
0A9E	0A09	sub     a, 9H
0A9F	390A	snz     Z
0AA0	6AA3	jmp     _L160
0AA1	0F40	mov     a, 40H
0AA2	43C3	addm    a, BarDisplayNum4[0]
				;441			
				;442			BarTimerCount = 0;
				_L160:
0AA3	5F47	clr     BarTimerCount[0]
0AA4	5F48	clr     BarTimerCount[1]
				;443			D_NUM1(Temp_Num2_H);
0AA5	473F	mov     a, Temp_Num2_H[0]
0AA6	40DF	mov     high, a
0AA7	0FC0	mov     a, C0H
0AA8	25A5	call    _display16
				;444			D_NUM2(Temp_Num2_L);
0AA9	4740	mov     a, Temp_Num2_L[0]
0AAA	40DF	mov     high, a
0AAB	0FC4	mov     a, C4H
0AAC	25A5	call    _display16
				;445			D_NUM3(Temp_Num1_H);
0AAD	4741	mov     a, Temp_Num1_H[0]
0AAE	40DF	mov     high, a
0AAF	0FC8	mov     a, C8H
0AB0	25A5	call    _display16
				;446		 	D_NUM4(Temp_Num1_L);
0AB1	4742	mov     a, Temp_Num1_L[0]
0AB2	40DF	mov     high, a
0AB3	0FCA	mov     a, CAH
0AB4	25A5	call    _display16
				;447			BarNum ++;
0AB5	54C9	inc     BarNum[0]
				_L155:
0AB6	0003	ret
				;448		}		
				;449	}
				;450	void NoPersonCheckFun(void)
				;451	{
				;452		if(KeyStatus == KeyPress)//改成while？？？
				_NoPersonCheckFun:
				_NoPersonCheckFun:
0AB7	573E	sdza    KeyStatus[0]
0AB8	6ABB	jmp     _L173
				;453		{
				;454			KeyCountOpenflag = 1;// delay();		
0AB9	0F01	mov     a, 1H
0ABA	40CF	mov     KeyCountOpenflag[0], a
				;455		}
				;456		if(1 == KeyCountOpenflag)
				_L173:
0ABB	574F	sdza    KeyCountOpenflag[0]
0ABC	6AC6	jmp     _L175
				;457		{
				;458			KeyCount++;
0ABD	54D0	inc     KeyCount[0]
				;459			if(KeyCount>150)
0ABE	0F96	mov     a, 96H
0ABF	4250	sub     a, KeyCount[0]
0AC0	3C0A	sz      C
0AC1	6AC6	jmp     _L175
				;460			{
				;461				KeyCount = 0;
0AC2	5F50	clr     KeyCount[0]
				;462				KeyCountOpenflag = 0;
0AC3	5F4F	clr     KeyCountOpenflag[0]
				;463				//Beep1 = Be																					epClose;
				;464				LED_UP = LED_DOWN = LedClose;//	= LEDSwitch 		
0AC4	3120	set     PB2
0AC5	30A0	set     PB1
				;465			}
				;466		}	
				;467		if(0 == PersonCheck)//
				_L175:
0AC6	3FB5	sz      PD7
0AC7	6AE1	jmp     _L177
				;468		{	
				;469			NoneTimerCount ++;
0AC8	0F01	mov     a, 1H
0AC9	43A5	addm    a, NoneTimerCount[0]
0ACA	0F00	mov     a, 0H
0ACB	53A6	adcm    a, NoneTimerCount[1]
0ACC	53A7	adcm    a, NoneTimerCount[2]
0ACD	53A8	adcm    a, NoneTimerCount[3]
				;470			personTimerCount = 0;
0ACE	5F29	clr     personTimerCount[0]
0ACF	5F2A	clr     personTimerCount[1]
				;471		
				;472			if(NoneTimerCount > 20000)//3min   10000 ---》30s
0AD0	0F20	mov     a, 20H
0AD1	4225	sub     a, NoneTimerCount[0]
0AD2	0F4E	mov     a, 4EH
0AD3	5226	sbc     a, NoneTimerCount[1]
0AD4	0F00	mov     a, 0H
0AD5	5227	sbc     a, NoneTimerCount[2]
0AD6	0F00	mov     a, 0H
0AD7	5228	sbc     a, NoneTimerCount[3]
0AD8	3C0A	sz      C
0AD9	6AF3	jmp     _L179
				;473			{								//60000 --- 》160s
				;474				NoneFlag = 1;//无人
0ADA	0F01	mov     a, 1H
0ADB	40AC	mov     NoneFlag[0], a
				;475				NoneTimerCount = 0;
0ADC	5F25	clr     NoneTimerCount[0]
0ADD	5F26	clr     NoneTimerCount[1]
0ADE	5F27	clr     NoneTimerCount[2]
0ADF	5F28	clr     NoneTimerCount[3]
0AE0	6AF3	jmp     _L179
				;476			}
				;477		}	
				;478		else
				;479		{	
				;480			NoneTimerCount = 0;
				_L177:
0AE1	5F25	clr     NoneTimerCount[0]
0AE2	5F26	clr     NoneTimerCount[1]
0AE3	5F27	clr     NoneTimerCount[2]
0AE4	5F28	clr     NoneTimerCount[3]
				;481			personTimerCount ++;
0AE5	54A9	inc     personTimerCount[0]
0AE6	3D0A	sz      Z
0AE7	54AA	inc     personTimerCount[1]
				;482		
				;483			if(personTimerCount > 300)
0AE8	0F2C	mov     a, 2CH
0AE9	4229	sub     a, personTimerCount[0]
0AEA	0F01	mov     a, 1H
0AEB	522A	sbc     a, personTimerCount[1]
0AEC	1185	swap    ACC
0AED	040A	xor     a, STATUS
0AEE	3985	snz     ACC.3
0AEF	6AF3	jmp     _L179
				;484			{
				;485				personTimerCount = 0;
0AF0	5F29	clr     personTimerCount[0]
0AF1	5F2A	clr     personTimerCount[1]
				;486				NoneFlag = 0;
0AF2	5F2C	clr     NoneFlag[0]
				;487			}
				;488		}
				;489	//	if((1 == NoneFlag)&&(1 == KeyFirstPressFlag))//屏幕关闭状态下，有按键
				;490	//	{
				;491			// KeyFirstPressFlag = 0;
				;492	//		NoneFlag = 0;	
				;493			// NoneErrorTimerCount++;
				;494	//	}
				;495		// if(NoneErrorTimerCount > 60000)//时间待确认
				;496		// {
				;497			// NoneErrorTimerCount = 0;
				;498			// KeyFirstPressFlag = 0;
				;499		// }
				;500		if(1 == KeyFirstPressFlag)
				_L179:
0AF3	574A	sdza    KeyFirstPressFlag[0]
0AF4	6AFC	jmp     _L181
				;501		{
				;502			NoneFlag = 0;
0AF5	5F2C	clr     NoneFlag[0]
				;503			NoneErrorTimerCount++;
0AF6	0F01	mov     a, 1H
0AF7	43A1	addm    a, NoneErrorTimerCount[0]
0AF8	0F00	mov     a, 0H
0AF9	53A2	adcm    a, NoneErrorTimerCount[1]
0AFA	53A3	adcm    a, NoneErrorTimerCount[2]
0AFB	53A4	adcm    a, NoneErrorTimerCount[3]
				;504			
				;505		}
				;506		if(NoneErrorTimerCount>600000)
				_L181:
0AFC	0FC0	mov     a, C0H
0AFD	4221	sub     a, NoneErrorTimerCount[0]
0AFE	0F27	mov     a, 27H
0AFF	5222	sbc     a, NoneErrorTimerCount[1]
0B00	0F09	mov     a, 9H
0B01	5223	sbc     a, NoneErrorTimerCount[2]
0B02	0F00	mov     a, 0H
0B03	5224	sbc     a, NoneErrorTimerCount[3]
0B04	3C0A	sz      C
0B05	6B0B	jmp     _L182
				;507		{
				;508			KeyFirstPressFlag = 0;
0B06	5F4A	clr     KeyFirstPressFlag[0]
				;509			NoneErrorTimerCount = 0;
0B07	5F21	clr     NoneErrorTimerCount[0]
0B08	5F22	clr     NoneErrorTimerCount[1]
0B09	5F23	clr     NoneErrorTimerCount[2]
0B0A	5F24	clr     NoneErrorTimerCount[3]
				;510		}	
				;511			
				;512		
				;513		if(0 == NoneFlag)//有人
				_L182:
0B0B	50AC	sz      NoneFlag[0]
0B0C	6B0F	jmp     _L183
				;514		{
				;515			ScreenDisplay();
0B0D	6248	call    _ScreenDisplay
0B0E	6B12	jmp     _L172
				;516		}
				;517		else			//无人
				;518		{
				;519			displayClear(0);
				_L183:
0B0F	5F5F	clr     high
0B10	5F60	clr     mid
0B11	2592	call    _displayClear
				_L172:
0B12	0003	ret
				;520		}		
				;521		
				;522	}
				;523	//***********************************************************
				;524	//*SUB. NAME:USER Main PROGRAM                              *
				;525	//*INPUT    :                                               *
				;526	//*OUTPUT   :                                               *
				;527	//*USED REG.:                                               *
				;528	//*FUNCTION :                                               *
				;529	//***********************************************************
				;530	void LEDX4_V16()
				;531	{
				;532		unsigned char flag;
				;533		if(1 == Beep1)
				_LEDX4_V16:
				_LEDX4_V16:
0B13	3994	snz     PA3
0B14	6B1C	jmp     _L186
				;534		{
				;535			BeepCount++;
0B15	54D3	inc     BeepCount[0]
				;536			if(BeepCount > 150)
0B16	0F96	mov     a, 96H
0B17	4253	sub     a, BeepCount[0]
0B18	3C0A	sz      C
0B19	6B1D	jmp     _L187
				;537				Beep1 = 0;
0B1A	3594	clr     PA3
0B1B	6B1D	jmp     _L187
				;538		}
				;539		else
				;540			BeepCount = 0;
				_L186:
0B1C	5F53	clr     BeepCount[0]
				;541		
				;542		Temp_Num2_L = T_valueGet%10;
				_L187:
0B1D	5F60	clr     mid
0B1E	471E	mov     a, T_valueGet[0]
0B1F	40DD	mov     Res, a
0B20	0F0A	mov     a, AH
0B21	40DE	mov     _DataSave_2, a
0B22	63C5	call    L0BC5
0B23	475F	mov     a, high
0B24	40C0	mov     Temp_Num2_L[0], a
				;543		Temp_Num2_H = T_valueGet/10;
0B25	5F60	clr     mid
0B26	471E	mov     a, T_valueGet[0]
0B27	40DD	mov     Res, a
0B28	0F0A	mov     a, AH
0B29	40DE	mov     _DataSave_2, a
0B2A	63C5	call    L0BC5
0B2B	475D	mov     a, Res
0B2C	40BF	mov     Temp_Num2_H[0], a
				;544		ADCGetFun();
0B2D	603D	call    _ADCGetFun
				;545		if(1 == ADCCompleteFlag)
0B2E	570D	sdza    ADCCompleteFlag[0]
0B2F	6B33	jmp     _L188
				;546		{ 
				;547			ADCCompleteFlag = 0;
0B30	5F0D	clr     ADCCompleteFlag[0]
				;548			flag =  ADC_Check();	//1;//
0B31	620B	call    _ADC_Check
0B32	40EB	mov     flag[0], a
				;549		}		
				;550		if(1 == flag)
				_L188:
0B33	576B	sdza    flag[0]
0B34	6B38	jmp     _L185
				;551		{
				;552			NoPersonCheckFun();	
0B35	62B7	call    _NoPersonCheckFun
				;553			TouchFun();
0B36	27BB	call    _TouchFun
				;554			IR_FUN();
0B37	2762	call    _IR_FUN
				_L185:
0B38	0003	ret
				;555		}
				;556	}
				;557	/******************************/
				;558	//void  time( )
				;559	/******************************/
				;560	void  isr_timer(void)
				;561	{
				@isr_timer_code .SECTION 'CODE'
000C	40DB	mov     r100, a
000D	070A	mov     a, STATUS
000E	40DC	mov     r200, a
000F	6B39	jmp     _isr_timer
				@dummy12 .SECTION 'CODE'
0010	0000	nop
0011	0000	nop
0012	0000	nop
0013	0000	nop
					----
					----
					----
					----
				L0018:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L008C:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L047F:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				;562		 _tf=0;	       // 清除溢出标记 
				_isr_timer:
				_isr_timer:
0B39	370E	clr     TF
				;563		 timerCount ++;
0B3A	0F01	mov     a, 1H
0B3B	43B6	addm    a, timerCount[0]
0B3C	0F00	mov     a, 0H
0B3D	53B7	adcm    a, timerCount[1]
0B3E	53B8	adcm    a, timerCount[2]
0B3F	53B9	adcm    a, timerCount[3]
				;564		 if(timerCount > timerCountSet)   //1S LED8灯闪烁一次
0B40	473A	mov     a, timerCountSet[0]
0B41	4236	sub     a, timerCount[0]
0B42	473B	mov     a, timerCountSet[1]
0B43	5237	sbc     a, timerCount[1]
0B44	473C	mov     a, timerCountSet[2]
0B45	5238	sbc     a, timerCount[2]
0B46	473D	mov     a, timerCountSet[3]
0B47	5239	sbc     a, timerCount[3]
0B48	3C0A	sz      C
0B49	6B51	jmp     _L190
				;565		 { 
				;566			timerCount = 0;		
0B4A	5F36	clr     timerCount[0]
0B4B	5F37	clr     timerCount[1]
0B4C	5F38	clr     timerCount[2]
0B4D	5F39	clr     timerCount[3]
				;567			timerFlag = Close;
0B4E	5F35	clr     timerFlag[0]
				;568			timer3sFlag = Close;
0B4F	5F34	clr     timer3sFlag[0]
				;569			TimerClose;	
0B50	361D	clr     TON
				_L190:
0B51	475C	mov     a, r200
0B52	008A	mov     STATUS, a
0B53	475B	mov     a, r100
0B54	0004	reti
0B55	0000	nop
0B56	0000	nop
				L0B57:
0B57	0000	nop
0B58	0000	nop
				L0B59:
0B59	0000	nop
				L0B5A:
0B5A	0000	nop
0B5B	1785	sdz     ACC
0B5C	6B5A	jmp     L0B5A
				L0B5D:
0B5D	0000	nop
0B5E	1785	sdz     ACC
0B5F	6B5D	jmp     L0B5D
0B60	57DD	sdz     Res
0B61	6B5D	jmp     L0B5D
0B62	0003	ret
				L0B63:
0B63	5F65	clr     _TouchFun_2[2]
0B64	5F66	clr     _TouchFun_2[3]
0B65	5F67	clr     _TouchFun_2[4]
0B66	5F68	clr     _TouchFun_2[5]
				L0B67:
0B67	7861	snz     _SunControl_2.0
0B68	6B71	jmp     L0B71
0B69	475D	mov     a, Res
0B6A	43E5	addm    a, _TouchFun_2[2]
0B6B	475E	mov     a, _DataSave_2
0B6C	53E6	adcm    a, _TouchFun_2[3]
0B6D	475F	mov     a, high
0B6E	53E7	adcm    a, _TouchFun_2[4]
0B6F	4760	mov     a, mid
0B70	53E8	adcm    a, _TouchFun_2[5]
				L0B71:
0B71	340A	clr     C
0B72	5ADD	rlc     Res
0B73	5ADE	rlc     _DataSave_2
0B74	5ADF	rlc     high
0B75	5AE0	rlc     mid
0B76	340A	clr     C
0B77	5BE4	rrc     _TouchFun_2[1]
0B78	5BE3	rrc     _TouchFun_2
0B79	5BE2	rrc     _SunControl_2[1]
0B7A	5BE1	rrc     _SunControl_2
0B7B	4761	mov     a, _SunControl_2
0B7C	4562	or      a, _SunControl_2[1]
0B7D	4563	or      a, _TouchFun_2
0B7E	4564	or      a, _TouchFun_2[1]
0B7F	390A	snz     Z
0B80	6B67	jmp     L0B67
0B81	0003	ret
				L0B82:
0B82	5F65	clr     _TouchFun_2[2]
0B83	5F66	clr     _TouchFun_2[3]
0B84	5F67	clr     _TouchFun_2[4]
0B85	5F68	clr     _TouchFun_2[5]
0B86	0F20	mov     a, 20H
0B87	40EA	mov     _TouchFun_2[7], a
				L0B88:
0B88	340A	clr     C
0B89	5ADD	rlc     Res
0B8A	5ADE	rlc     _DataSave_2
0B8B	5ADF	rlc     high
0B8C	5AE0	rlc     mid
0B8D	5AE5	rlc     _TouchFun_2[2]
0B8E	5AE6	rlc     _TouchFun_2[3]
0B8F	5AE7	rlc     _TouchFun_2[4]
0B90	5AE8	rlc     _TouchFun_2[5]
0B91	4765	mov     a, _TouchFun_2[2]
0B92	4261	sub     a, _SunControl_2
0B93	4766	mov     a, _TouchFun_2[3]
0B94	5262	sbc     a, _SunControl_2[1]
0B95	4767	mov     a, _TouchFun_2[4]
0B96	5263	sbc     a, _TouchFun_2
0B97	4768	mov     a, _TouchFun_2[5]
0B98	5264	sbc     a, _TouchFun_2[1]
0B99	380A	snz     C
0B9A	6BA8	jmp     L0BA8
0B9B	4765	mov     a, _TouchFun_2[2]
0B9C	4261	sub     a, _SunControl_2
0B9D	40E5	mov     _TouchFun_2[2], a
0B9E	4766	mov     a, _TouchFun_2[3]
0B9F	5262	sbc     a, _SunControl_2[1]
0BA0	40E6	mov     _TouchFun_2[3], a
0BA1	4767	mov     a, _TouchFun_2[4]
0BA2	5263	sbc     a, _TouchFun_2
0BA3	40E7	mov     _TouchFun_2[4], a
0BA4	4768	mov     a, _TouchFun_2[5]
0BA5	5264	sbc     a, _TouchFun_2[1]
0BA6	40E8	mov     _TouchFun_2[5], a
0BA7	54DD	inc     Res
				L0BA8:
0BA8	57EA	sdz     _TouchFun_2[7]
0BA9	6B88	jmp     L0B88
0BAA	7869	snz     _TouchFun_2[6].0
0BAB	6BB7	jmp     L0BB7
0BAC	41E5	cpl     _TouchFun_2[2]
0BAD	41E6	cpl     _TouchFun_2[3]
0BAE	41E7	cpl     _TouchFun_2[4]
0BAF	41E8	cpl     _TouchFun_2[5]
0BB0	54E5	inc     _TouchFun_2[2]
0BB1	3D0A	sz      Z
0BB2	54E6	inc     _TouchFun_2[3]
0BB3	3D0A	sz      Z
0BB4	54E7	inc     _TouchFun_2[4]
0BB5	3D0A	sz      Z
0BB6	54E8	inc     _TouchFun_2[5]
				L0BB7:
0BB7	78E9	snz     _TouchFun_2[6].1
0BB8	6BC4	jmp     L0BC4
0BB9	41DD	cpl     Res
0BBA	41DE	cpl     _DataSave_2
0BBB	41DF	cpl     high
0BBC	41E0	cpl     mid
0BBD	54DD	inc     Res
0BBE	3D0A	sz      Z
0BBF	54DE	inc     _DataSave_2
0BC0	3D0A	sz      Z
0BC1	54DF	inc     high
0BC2	3D0A	sz      Z
0BC3	54E0	inc     mid
				L0BC4:
0BC4	0003	ret
				L0BC5:
0BC5	5F5F	clr     high
0BC6	0F08	mov     a, 8H
0BC7	40E1	mov     _SunControl_2, a
				L0BC8:
0BC8	340A	clr     C
0BC9	5ADD	rlc     Res
0BCA	5ADF	rlc     high
0BCB	475F	mov     a, high
0BCC	425E	sub     a, _DataSave_2
0BCD	380A	snz     C
0BCE	6BD3	jmp     L0BD3
0BCF	475F	mov     a, high
0BD0	425E	sub     a, _DataSave_2
0BD1	40DF	mov     high, a
0BD2	54DD	inc     Res
				L0BD3:
0BD3	57E1	sdz     _SunControl_2
0BD4	6BC8	jmp     L0BC8
0BD5	7C60	sz      mid.0
0BD6	41DF	cpl     high
0BD7	7C60	sz      mid.0
0BD8	54DF	inc     high
0BD9	7CE0	sz      mid.1
0BDA	41DD	cpl     Res
0BDB	7CE0	sz      mid.1
0BDC	54DD	inc     Res
0BDD	0003	ret
				L0BDE:
0BDE	1483	inc     MP1
0BDF	3D0A	sz      Z
0BE0	1481	inc     MP0
				L0BE1:
0BE1	3F81	sz      MP0.7
0BE2	6BE7	jmp     L0BE7
0BE3	0701	mov     a, MP0
0BE4	0084	mov     BP, a
0BE5	0702	mov     a, [02H]
0BE6	0003	ret
				L0BE7:
0BE7	1B01	rrca    MP0
0BE8	0E3F	and     a, 3FH
0BE9	0089	mov     TBHP, a
0BEA	1B03	rrca    MP1
0BEB	0087	mov     TBLP, a
0BEC	1D05	tabrd   ACC
0BED	3C0A	sz      C
0BEE	0708	mov     a, TBLH
0BEF	0003	ret
				;570		 }  
				;571	}
				;572	
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\LEDX4_V16\LEDX4_V16.h
				;1	/*************************************************************************************************************************
				;2	 * Created by: Holtek Touch MCU Workshop, Version 3.5.0.0
				;3	 * LEDX4_V16.H
				;4	 * 03:02:23 PM Saturday, December 16, 2017
				;5	*************************************************************************************************************************/
				;6	#include "..\TKS_GLOBE_VARIES.h" 
				;7	#include "..\BS84B08A_LIBV413\BS84B08A_LIBV413.cex" 
				;8	#include "..\MAIN_PROGRAM_V104\MAIN_PROGRAM_V104.cex" 
				;9	#include "..\USER_PROGRAM\USER_PROGRAM.cex" 
				;10	
				;11	#define _LEDX4_V16_ 
				;12	#define LEDSwitch       _pa1
				;13	#define LEDSwitch_C     _pac1
				;14	#define LED_DOWN        _pb2
				;15	#define LED_DOWN_C      _pbc2
				;16	#define LED_UP          _pb1
				;17	#define LED_UP_C        _pbc1
				;18	#define Beep1           _pa3
				;19	#define Beep1_C         _pac3
				;20	#define Temp1           _pd0
				;21	#define Temp1_C         _pdc0
				;22	#define BeepOpen        1
				;23	#define BeepClose       0
				;24	#define LedOpen         0
				;25	#define LedClose        1
				;26	volatile unsigned char BeepCount ;
				;27	//Relay
				;28	#define RelayOpen       1
				;29	#define RelayClose      0
				;30	//KeyPress
				;31	#define OUTPUT_LEVEL    0  // GND
				;32	#define KeyPress        1
				;33	#define KeyRelease      0
				;34	#define KeySitchON      1
				;35	#define KeySitchOFF     0
				;36	volatile unsigned char KeyPressFlag;//0 有人 ，1 没人
				;37	
				;38	volatile unsigned char KeySwitchStatus ;
				;39	volatile unsigned char KeyCount ;
				;40	volatile unsigned char KeyCountOpenflag ;
				;41	/*const unsigned short TempForm[]={	1673, 1589, 1509, 1434, 1363, 1295, 1232, 1172, 1115, 1061, 
				;42										1010, 962, 917, 873, 833, 794, 757, 722, 689, 658, 
				;43										628, 600, 573, 547, 523, 500, 478, 457, 437, 419, 
				;44										401, 384, 367, 352, 337, 323, 310, 297, 285, 273, 
				;45										262, 251, 241, 231, 222, 213, 205, 197, 189, 182, 
				;46										175, 168, 162, 155, 150, 144, 139, 133, 128, 124, 
				;47										119, 115, 111, 107, 103, 99, 95, 92, 89, 86, 
				;48										83, 80, 77, 74, 72, 69, 67, 65, 62, 60, 
				;49										58, 56, 54, 53, 51, 49, 48, 46, 45, 43, 
				;50										42, 40, 39, 38, 37, 36, 34, 33, 32, 31, 
				;51										30 };
				;52	*/									
				;53	//
				;54	const unsigned short TempForm[]={ 	1630, 1549, 1473, 1401, 1333, 1268, 1208, 1150, 1095, 1044, 
0501	065E	and     a, __pdpu[39]
0502	060D	and     a, INTEG
0503	05C1	orm     a, __pdpu[10]
0504	0579	or      a, __pdpu[66]
0505	0535	or      a, PD
0506	04F4	xorm    a, __pdpu[61]
0507	04B8	xorm    a, __pdpu[1]
0508	047E	xor     a, __pdpu[71]
0509	0447	xor     a, TKC1
050A	0414	xor     a, PA
050B	03E3	addm    a, __pdpu[44]
050C	03B4	addm    a, __acerl[2]
050D	0388	addm    a, TBLH
050E	035F	add     a, __pdpu[40]
050F	0337	add     a, PDPU
0510	0312	add     a, __intc0[4]
0511	02EE	subm    a, __pdpu[55]
0512	02CC	subm    a, TKM0C0
0513	02AC	subm    a, __pbpu[10]
0514	028E	subm    a, INTC0
0515	0271	sub     a, __pdpu[58]
0516	0255	sub     a, __pdpu[30]
0517	023B	sub     a, __pdpu[4]
0518	0222	sub     a, PBPU
0519	020A	sub     a, STATUS
051A	01F4	cpl     __pdpu[61]
051B	01DF	cpl     __pdpu[40]
051C	01CA	cpl     TKM0ROL
051D	01B7	cpl     PDPU
051E	01A4	cpl     SIMC0
051F	0193	cpl     LVRC
0520	0182	cpl     [02H]
0521	0172	cpla    __pdpu[59]
0522	0163	cpla    __pdpu[44]
0523	0154	cpla    __pdpu[29]
0524	0146	cpla    TK16DH
0525	0139	cpla    __pdpu[2]
0526	012C	cpla    __pbpu[10]
0527	0120	cpla    PB
0528	0115	cpla    PAC
0529	010A	cpla    STATUS
052A	00FF	mov     __pdpu[72], a
052B	00F5	mov     __pdpu[62], a
052C	00EC	mov     __pdpu[53], a
052D	00E3	mov     __pdpu[44], a
052E	00DA	mov     __pdpu[35], a
052F	00D1	mov     TKM1ROH, a
0530	00C9	mov     TKM016DH, a
0531	00C2	mov     __pdpu[11], a
0532	00BA	mov     __pdpu[3], a
0533	00B3	mov     __acerl[1], a
0534	00AD	mov     __pbpu[11], a
0535	00A6	mov     SIMD, a
0536	00A0	mov     PB, a
0537	009A	mov     WDTC, a
0538	0095	mov     PAC, a
0539	008F	mov     INTC1, a
053A	008A	mov     STATUS, a
053B	0085	mov     ACC, a
053C	0080	mov     [00H], a
053D	007B	dc	0007BH
053E	0077	dc	00077H
053F	0073	dc	00073H
0540	006F	dc	0006FH
0541	006B	dc	0006BH
0542	0067	dc	00067H
0543	0064	dc	00064H
0544	0060	dc	00060H
0545	005D	dc	0005DH
0546	005A	dc	0005AH
0547	0057	dc	00057H
0548	0054	dc	00054H
0549	0051	dc	00051H
054A	004E	dc	0004EH
054B	004B	dc	0004BH
054C	0049	dc	00049H
054D	0047	dc	00047H
054E	0044	dc	00044H
054F	0042	dc	00042H
0550	0040	dc	00040H
0551	003E	dc	0003EH
0552	003C	dc	0003CH
0553	003A	dc	0003AH
0554	0038	dc	00038H
0555	0036	dc	00036H
0556	0034	dc	00034H
0557	0033	dc	00033H
0558	0031	dc	00031H
0559	0030	dc	00030H
055A	002E	dc	0002EH
055B	002D	dc	0002DH
055C	002B	dc	0002BH
055D	002A	dc	0002AH
055E	0029	dc	00029H
055F	0027	dc	00027H
0560	0026	dc	00026H
0561	0025	dc	00025H
0562	0024	dc	00024H
0563	0023	dc	00023H
0564	0022	dc	00022H
0565	0021	dc	00021H
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0566	0004	reti
0567	0085	mov     ACC, a
0568	0000	nop
0569	0000	nop
056A	0000	nop
056B	004B	dc	0004BH
056C	0089	mov     TBHP, a
056D	0000	nop
				;55										995, 948, 904, 863, 823, 786, 750, 716, 684, 654, 
				;56										625, 597, 571, 546, 522, 500, 479, 458, 439, 420, 
				;57										403, 386, 370, 355, 340, 326, 313, 300, 288, 277, 
				;58										266, 255, 245, 236, 227, 218, 209, 201, 194, 186, 
				;59										179, 173, 166, 160, 154, 149, 143, 138, 133, 128, 
				;60										123, 119, 115, 111, 107, 103, 100, 96, 93, 90, 
				;61										87, 84, 81, 78, 75, 73, 71, 68, 66, 64, 
				;62										62, 60, 58, 56, 54, 52, 51, 49, 48, 46, 
				;63										45, 43, 42, 41, 39, 38, 37, 36, 35, 34, 
				;64										33};
				;65										
				;66	//TIM1628
				;67	#define CLK1_C 	_pac7
				;68	#define CLK1 	_pa7
				;69	#define DIO1_C 	_pac4
				;70	#define DIO1 	_pa4
				;71	#define STB1_C 	_pdc1
				;72	#define STB1 	_pd1
				;73	//adc relay
				;74	#define Relay_HEAT_C    _pac0//加热
				;75	#define Relay_HEAT    	_pa0//加热
				;76	#define Relay_PV_C   	_pac2//光伏
				;77	#define Relay_PV    	_pa2//光伏
				;78	#define RelayHeatOpen   _pa0 = 1;//
				;79	#define RelayHeatClose  _pa0 = 0;//
				;80	#define RelayPVOpen    	_pa2 = 0;//
				;81	#define RelayPVClose    _pa2 = 1;//
				;82	//去除显示
				;83	#define ND_ERROR 	   	display16(0xcc,0x0010); 
				;84	//显示
				;85	#define D_PV() 			C8Value = 0x10;///display16(0xc8,0 , 0x0010);
				;86	#define ND_PV() 		C8Value = 0x00;///display16(0xc8,0 , 0x0010);	
				;87	#define D_WarmKeep()	C8Value2 = 0x20;//display16(0xc8,x,0);		
				;88	#define ND_WarmKeep()	C8Value2 = 0x00;//display16(0xc8,x,0);	
				;89	#define D_Heat() 		CaValue = 0x10;// display16(0xca,0 , 0x1000);
				;90	#define ND_Heat() 		CaValue = 0x00;//display16(0xca,0 , 0x0000);
				;91	#define D_ERROR() 	   	display16(0xcc,0); 
				;92	
				;93	
				;94	#define D_NUM1(x) display16(0xc0,x);
				;95	#define D_NUM2(x) display16(0xc4,x);
				;96	#define D_NUM3(x) display16(0xc8,x);
				;97	#define D_NUM4(x) display16(0xca,x);
				;98	// #define D_E2 display16(0xc0,0x0e,0);display16(0xc4,0x02,0);
				;99	#define D_E2 C_Display = 0;display16(0xc0,0x0e);display16(0xc4,0x02);	display16(0xcc,0x10); 
				;100	// #define D_E1 display16(0xc0,0x0e,0);display16(0xc4,0x01,0);
				;101	#define D_E1 C_Display = 0;display16(0xc0,0x0e);display16(0xc4,0x01);	display16(0xcc,0x10); 
				;102	
				;103	volatile unsigned char C8Value ;//用与光伏  
				;104	volatile unsigned char C8Value2 ;//用与  保温 
				;105	volatile unsigned char CaValue ;
				;106	volatile unsigned char C_Display;//C c显示
				;107	volatile unsigned char KeyFirstPressFlag ;
				;108	//volatile unsigned char CCValue = 0;
				;109	
				;110	volatile unsigned char BarNum 		;
				;111	volatile unsigned short BarTimerCount ;
				;112	short const CODE[]={ 0x0387,0x0180,0x030B,0x0389,0x018C,0x028D,0x028F,0x0380,0x038F,0x038D,\
04F0	0387	addm    a, TBLP
04F1	0180	cpl     [00H]
04F2	030B	add     a, SMOD
04F3	0389	addm    a, TBHP
04F4	018C	cpl     CTRL
04F5	028D	subm    a, INTEG
04F6	028F	subm    a, INTC1
04F7	0380	addm    a, [00H]
04F8	038F	addm    a, INTC1
04F9	038D	addm    a, INTEG
04FA	038E	addm    a, INTC0
04FB	008F	mov     INTC1, a
04FC	0207	sub     a, TBLP
04FD	018B	cpl     SMOD
04FE	020F	sub     a, INTC1
04FF	020E	sub     a, INTC0
0500	0000	nop
				;113	0x038E,0x008F,0x0207,0x018B,0x020F,0x020E,0x0000}; //数码管0-F的编码  
				;114	//a     b      c     d     e      f       
				;115	volatile unsigned char BarDisplayNum1 ;
				;116	volatile unsigned char BarDisplayNum2 ;
				;117	volatile unsigned char BarDisplayNum3 ;
				;118	volatile unsigned char BarDisplayNum4 ;
				;119	
				;120	#define Temp_Num1  Temp_Num1_H*10 + Temp_Num1_L
				;121	volatile unsigned char Temp_Num1_L;//预设值
				;122	volatile unsigned char Temp_Num1_H;
				;123	#define Temp_Num2  Temp_Num2_H*10 + Temp_Num2_L
				;124	volatile unsigned char Temp_Num2_L ;
				;125	volatile unsigned char Temp_Num2_H ;
				;126	volatile unsigned char KeyStatus ;
				;127	
				;128	
				;129	
				;130	//Timer
				;131	#define Open        1
				;132	#define Close       0
				;133	
				;134	volatile unsigned long 		timerCountSet ;
				;135	//volatile unsigned char 	timerVoerFlag = 0;
				;136	volatile unsigned long 		timerCount ;
				;137	// volatile unsigned int  		timerBaseCount = 0;
				;138	
				;139	volatile unsigned char 		timerFlag ;
				;140	
				;141	volatile unsigned char 		timer3sFlag ;//switch on/off 3s检查标记
				;142	volatile unsigned char 		timer1hourFlag;//HeatOpen 1 hour 检查标记
				;143	
				;144	
				;145	#define  TimerOpen	_ton = 1;	
				;146	#define	 TimerClose _ton = 0;
				;147	// 红外
				;148	#define IR_Out  	_pb5//对应红外引脚输入
				;149	#define Delay1us  	GCC_DELAY(2) 
				;150	#define Delay1ms  	GCC_DELAY(2000) 
				;151	#define Delay800us  GCC_DELAY(1600) 
				;152	#define Delay1150us GCC_DELAY(2300) 
				;153	#define Delay2272us GCC_DELAY(4544) 
				;154	
				;155	
				;156	volatile unsigned long 	IRCount ;
				;157	
				;158	
				;159	
				;160	volatile unsigned char _datasave[4] = {};
				;161	volatile unsigned char StartFlag ;
				;162	volatile unsigned char BOOT_REPEATING_CODE_Flag ;  
				;163	//人体感应
				;164	#define PersonCheck_C 	_pdc7//对应红外引脚输入
				;165	#define PersonCheck 	_pd7//对应红外引脚输入
				;166	volatile char NoneFlag;//0 有人 ，1 没人
				;167	volatile char PersonCheckDisable;//0 红外缺失  1 红外还在
				;168	volatile short personTimerCount;
				;169	
				;170	volatile unsigned long NoneTimerCount;
				;171	volatile unsigned long NoneErrorTimerCount;//屏幕开启后的关闭
				;172	
				;173	
				;174	
				;175	
				;176	
				;177	
				;178	
				;179	//Warning
				;180	volatile unsigned char E2WaringFlag ;
				;181	volatile unsigned char E1WaringFlag ;
				;182	
				;183	//Adc
				;184	// volatile float T_value ;
				;185	volatile unsigned char T_valueGet ;
				;186	
				;187	volatile unsigned int dat;
				;188	
				;189	volatile unsigned long T_value ;//电阻阻值 
				;190	volatile unsigned long R_value ;//电阻阻值 
				;191	volatile unsigned long R_valueSum ;//电阻阻值 
				;192	volatile unsigned short ADCCount ;//电阻阻值 
				;193	volatile unsigned char ADCCompleteFlag ;//电阻阻值 
				;194	volatile unsigned int intTemp1 ;//电阻阻值 
				;195	// volatile unsigned int intTemp2 ;//电阻阻值 
				;196	// volatile unsigned int intTemp3 ;//电阻阻值 
				;197	// volatile unsigned long longTemp1 ;//电阻阻值 
				;198	// volatile unsigned long longTemp2 ;//电阻阻值 
				;199	// volatile unsigned long longTemp3 ;//电阻阻值 
				;200	// volatile unsigned long longTemp4 ;//电阻阻值 
				;201	
				;202	// const unsigned char R = 20;	 //串联电阻阻值
				;203	// const float a = 0.001021;
				;204	// const float b = -0.3775;
				;205	// const float c = 32.69;
				;206	// const float d = 481.3;
				;207	// const float e = -1428;
				;208	// const unsigned short f = 1838;
				;209	// volatile float a ;
				;210	// volatile float b ;
				;211	// volatile float c ;
				;212	// volatile float d ;
				;213	// volatile float e ;
				;214	// volatile unsigned short f ;
				;215	//	R_value = 33;//预设值，待修改
				;216	// 加热
				;217	// volatile unsigned char RelayHeatFlag = 0;
				;218	
				;219	//
				;220	#define StatusIdle			0 
				;221	#define StatusSwitchON		1
				;222	#define StatusSwitchOFF		2
				;223	#define StatusHeatOpen		3
				;224	#define StatusHeatcontinue	4
				;225	#define StatusWarmHold 		5
				;226	#define StatusHeatComplete	6
				;227	#define StatusE1			7
				;228	#define StatusE2			8
				;229	// #define StatusIdle 			5
				;230	volatile unsigned char ControlFlag ;
				;231	void TimerSetFun( unsigned long TimerCsountValieSet );
				;232	void SunControl(void);
				;233	void NoPersonCheckFun(void);
				;234	
				;235	// #define TimerSetFun(x)	TimerClose;\
				;236						// timerCount = 0;\
				;237						// timerCountSet = x;\
				;238						// TimerOpen;\
				;239						// timerFlag = Open;
				;240	
				;241	
				;242	/*				
				;243						timerCount = 0; //定时器计数清零
				;244						timerCountSet = 2000;//鸣笛定时 3s  //计数量设置
				;245						TimerOpen;//定时器打开
				;246						timerFlag = Open; //定时器 标记 开始	
				;247	
				;248	*/
				;249	
				;250	
				;251	
				;252	
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\LEDX4_V16\Src\TIM1628.c
				;1	/*****************************
				;2	
				;3		TM1628
				;4	
				;5	*****************************/
				;6	
				;7	//向TM1628发送8位数据,从低位开始
				;8	 void send_8bit(unsigned char dat) 
				;9	{ 
				_send_8bit:
				_send_8bit:
056E	40DD	mov     dat[0], a
056F	0F08	mov     a, 8H
0570	40D4	mov     ra, a
				;10	  	unsigned char i; 
				;11		for(i=0;i<8;i++) 
				;12	   	{ 
				;13			if(dat&0x01)
				L0571:
0571	785D	snz     dat[0].0
0572	2D75	jmp     L0575
				;14				DIO1=1; 
0573	3214	set     PA4
0574	2D76	jmp     L0576
				;15		  	else 
				;16		  		DIO1=0; 
				L0575:
0575	3614	clr     PA4
				;17		   	CLK1=0; //下降沿输出数据
				L0576:
0576	3794	clr     PA7
				;18		   	// _nop();//还需要修改，_nop() 函式只需一指令L期 us(微秒)，这个需要结合具体芯片   	CLK1=1; 
				;19		   	CLK1=1; //下降沿输出数据
0577	3394	set     PA7
				;20	
				;21	    	dat=dat>>1; 
0578	340A	clr     C
0579	5BDD	rrc     dat[0]
057A	57D4	sdz     ra
057B	2D71	jmp     L0571
057C	0003	ret
				;22		} 
				;23	}
				;24	//向TM1628发送16位数据,从低位开始
				;25	 void send_16bit(unsigned short dat) 
				;26	{ 
				_send_16bit:
				_send_16bit:
057D	0F10	mov     a, 10H
057E	40D4	mov     ra, a
				;27	  	unsigned char i; 
				;28		// unsigned char value ;
				;29		// value = dat;
				;30		// send_8bit(value);
				;31		// value = dat<<8;
				;32		// send_8bit(value);
				;33		
				;34		 for(i=0;i<16;i++) 
				;35	   	 { 
				;36			if(dat&0x01)
				_L11:
057F	785D	snz     dat[0].0
0580	2D83	jmp     _L8
				;37				DIO1=1; 
0581	3214	set     PA4
0582	2D84	jmp     _L9
				;38		  	else 
				;39		  		DIO1=0; 
				_L8:
0583	3614	clr     PA4
				;40		   	CLK1=0; //下降沿输出数据
				_L9:
0584	3794	clr     PA7
				;41		   	CLK1=1; //下降沿输出数据
0585	3394	set     PA7
				;42	    	dat=dat>>1; 
0586	340A	clr     C
0587	5BDE	rrc     dat[1]
0588	5BDD	rrc     dat[0]
0589	57D4	sdz     ra
058A	2D7F	jmp     _L11
058B	0003	ret
				;43		 } 
				;44	}
				;45	//向TM1628发送命令 
				;46	void command(unsigned char com) 
				;47	{ 
				_command:
				_command:
058C	40DE	mov     com[0], a
				;48		STB1 = 1; //为低后第一个字节为命令
058D	30B5	set     PD1
				;49		STB1 = 0; 
058E	34B5	clr     PD1
				;50		send_8bit(com); 
058F	475E	mov     a, com[0]
0590	256E	call    _send_8bit
0591	0003	ret
				;51	}
				;52	// command(0x8F);      //显示控制命令，打开显示并设置为最亮 
				;53	// command(0x88);      //显示控制命令，打开显示并设置为最暗  
				;54	// 显示初始化清除所有
				;55	void displayClear(unsigned short value) 
				;56	{ 
				;57	  	unsigned char i; 
				;58	  	command(0x03);      //设置显示模式，7位10段模式  //	2 6位11段 --	//待修改
				_displayClear:
				_displayClear:
0592	0F03	mov     a, 3H
0593	258C	call    _command
				;59	  	command(0x40);      //设置数据命令,采用地址自动加1模式 	//
0594	0F40	mov     a, 40H
0595	258C	call    _command
				;60	  	command(0xc0);      //设置显示地址，从C0H开始 			//	
0596	0FC0	mov     a, C0H
0597	258C	call    _command
0598	0F0A	mov     a, AH
0599	40E1	mov     _SunControl_2, a
				;61	  	for(i=0;i<10;i++)    //发送显示数据 
				;62	  	{ 
				;63			send_16bit(value);     //从C0H
				_L15:
059A	475F	mov     a, value[0]
059B	40DD	mov     Res, a
059C	4760	mov     a, value[1]
059D	40DE	mov     _DataSave_2, a
059E	257D	call    _send_16bit
059F	57E1	sdz     _SunControl_2
05A0	2D9A	jmp     _L15
				;64		} 
				;65		command(0x8F);          //
05A1	0F8F	mov     a, 8FH
05A2	258C	call    _command
				;66		STB1=1; 
05A3	30B5	set     PD1
05A4	0003	ret
				;67	}
				;68	//设置地址和显示内容---数字  status 显示的标记 eg: C c PV Heat 等
				;69	void display16(unsigned char adress,unsigned char NUM) 
				;70	{ 
				_display16:
				_display16:
05A5	40E0	mov     adress[0], a
				;71	
				;72		command(0x03);      	//设置显示模式，7位10段模式  //	2 6位11段 --	//待修改
05A6	0F03	mov     a, 3H
05A7	258C	call    _command
				;73	  	command(0x40);      	//设置数据命令,采用地址自动加1模式 	//
05A8	0F40	mov     a, 40H
05A9	258C	call    _command
				;74	  	command(adress);      	//设置显示地址，从C0H开始 			//	
05AA	4760	mov     a, adress[0]
05AB	258C	call    _command
				;75	  	
				;76		switch ( adress)
05AC	4760	mov     a, adress[0]
05AD	0AC0	sub     a, C0H
05AE	3D0A	sz      Z
05AF	2DC3	jmp     L05C3
05B0	0A04	sub     a, 4H
05B1	3D0A	sz      Z
05B2	2DE1	jmp     L05E1
05B3	4760	mov     a, adress[0]
05B4	0AC8	sub     a, C8H
05B5	3D0A	sz      Z
05B6	2DFF	jmp     L05FF
05B7	4760	mov     a, adress[0]
05B8	0ACA	sub     a, CAH
05B9	390A	snz     Z
05BA	2E1D	jmp     L061D
				;77		{
				;78			case 0xc0 :
				;79				send_16bit(CODE[NUM] + BarDisplayNum1 );  			
				L05C3:
05C3	475F	mov     a, NUM[0]
05C4	40D5	mov     rb, a
05C5	5F56	clr     rc
05C6	340A	clr     C
05C7	5AD5	rlc     rb
05C8	5AD6	rlc     rc
05C9	0FE0	mov     a, E0H
05CA	4355	add     a, rb
05CB	0083	mov     MP1, a
05CC	0F89	mov     a, 89H
05CD	5356	adc     a, rc
05CE	0081	mov     MP0, a
05CF	63E1	call    L0BE1
05D0	40E1	mov     _SunControl_2, a
05D1	63DE	call    L0BDE
05D2	40E2	mov     _SunControl_2[1], a
05D3	4746	mov     a, BarDisplayNum1[0]
05D4	4361	add     a, _SunControl_2
05D5	40DD	mov     Res, a
05D6	1F05	clr     ACC
05D7	5362	adc     a, _SunControl_2[1]
05D8	40DE	mov     _DataSave_2, a
05D9	257D	call    _send_16bit
				;80				// send_16bit(CODE[NUM]);  
				;81				send_16bit(CODE[NUM] + BarDisplayNum2);  		////加上C加上c	
05DA	4745	mov     a, BarDisplayNum2[0]
05DB	4361	add     a, _SunControl_2
05DC	40DD	mov     Res, a
05DD	1F05	clr     ACC
05DE	5362	adc     a, _SunControl_2[1]
05DF	40DE	mov     _DataSave_2, a
05E0	2E20	jmp     L0620
				;82			break;
				;83			case 0xc4:
				;84				send_16bit(CODE[NUM] + BarDisplayNum3);  
				L05E1:
05E1	475F	mov     a, NUM[0]
05E2	40D5	mov     rb, a
05E3	5F56	clr     rc
05E4	340A	clr     C
05E5	5AD5	rlc     rb
05E6	5AD6	rlc     rc
05E7	0FE0	mov     a, E0H
05E8	4355	add     a, rb
05E9	0083	mov     MP1, a
05EA	0F89	mov     a, 89H
05EB	5356	adc     a, rc
05EC	0081	mov     MP0, a
05ED	63E1	call    L0BE1
05EE	40E1	mov     _SunControl_2, a
05EF	63DE	call    L0BDE
05F0	40E2	mov     _SunControl_2[1], a
05F1	4744	mov     a, BarDisplayNum3[0]
05F2	4361	add     a, _SunControl_2
05F3	40DD	mov     Res, a
05F4	1F05	clr     ACC
05F5	5362	adc     a, _SunControl_2[1]
05F6	40DE	mov     _DataSave_2, a
05F7	257D	call    _send_16bit
				;85				send_16bit(CODE[NUM]+ C_Display);  ////加上C加上c		
05F8	474B	mov     a, C_Display[0]
05F9	4361	add     a, _SunControl_2
05FA	40DD	mov     Res, a
05FB	1F05	clr     ACC
05FC	5362	adc     a, _SunControl_2[1]
05FD	40DE	mov     _DataSave_2, a
05FE	2E20	jmp     L0620
				;86			break;		
				;87			case 0xc8:
				;88				send_16bit(CODE[NUM] + C8Value + C8Value2); 
				L05FF:
05FF	474E	mov     a, C8Value[0]
0600	40D7	mov     rd, a
0601	5F58	clr     re
0602	474D	mov     a, C8Value2[0]
0603	43D7	addm    a, rd
0604	3C0A	sz      C
0605	54D8	inc     re
				;89			break;			
				;90			case 0xca:
				;91				send_16bit(CODE[NUM] + BarDisplayNum4 + CaValue); 
05BB	4743	mov     a, BarDisplayNum4[0]
05BC	40D7	mov     rd, a
05BD	5F58	clr     re
05BE	474C	mov     a, CaValue[0]
05BF	43D7	addm    a, rd
05C0	3C0A	sz      C
05C1	54D8	inc     re
05C2	2E06	jmp     L0606
				L0606:
0606	475F	mov     a, NUM[0]
0607	40D5	mov     rb, a
0608	5F56	clr     rc
0609	340A	clr     C
060A	5AD5	rlc     rb
060B	5AD6	rlc     rc
060C	0FE0	mov     a, E0H
060D	4355	add     a, rb
060E	0083	mov     MP1, a
060F	0F89	mov     a, 89H
0610	5356	adc     a, rc
0611	0081	mov     MP0, a
0612	63E1	call    L0BE1
0613	40D5	mov     rb, a
0614	63DE	call    L0BDE
0615	40D6	mov     rc, a
0616	4755	mov     a, rb
0617	4357	add     a, rd
0618	40DD	mov     Res, a
0619	4756	mov     a, rc
061A	5358	adc     a, re
061B	40DE	mov     _DataSave_2, a
061C	2E20	jmp     L0620
				;92			break;		
				;93			default:
				;94				send_16bit(0x0040);  
				L061D:
061D	0F40	mov     a, 40H
061E	40DD	mov     Res, a
061F	5F5E	clr     _DataSave_2
				L0620:
0620	257D	call    _send_16bit
0621	0003	ret
				;95			break;
				;96		}
				;97	}
				;98	//单个字符显示 
				;99	void displayTwst(unsigned char adress,unsigned short test) 
				;100	{ 
				_displayTwst:
				_displayTwst:
0622	40E1	mov     adress[0], a
				;101	  	command(0x03);      	//设置显示模式，7位10段模式  //	2 6位11段 --	//待修改
0623	0F03	mov     a, 3H
0624	258C	call    _command
				;102	  	command(0x40);      	//设置数据命令,采用地址自动加1模式 	//
0625	0F40	mov     a, 40H
0626	258C	call    _command
				;103	  	command(adress);      	//设置显示地址	
0627	4761	mov     a, adress[0]
0628	258C	call    _command
				;104		send_16bit(test);  		//
0629	475F	mov     a, test[0]
062A	40DD	mov     Res, a
062B	4760	mov     a, test[1]
062C	40DE	mov     _DataSave_2, a
062D	257D	call    _send_16bit
				;105		command(0x8F);          //
062E	0F8F	mov     a, 8FH
062F	258C	call    _command
				;106		STB1=1; 
0630	30B5	set     PD1
0631	0003	ret
				;107	} 
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\LEDX4_V16\Src\Key.c
				;1	 /*****************************
				;2	
				;3		Touch
				;4	
				;5	*****************************/
				;6	unsigned char KeyDownProcess(void)
				;7	{
				;8		Beep1 = BeepOpen;
				_KeyDownProcess:
				_KeyDownProcess:
0632	3194	set     PA3
				;9	//	KeyPressFlag = 1;
				;10		if(1 == NoneFlag)//无人下
0633	572C	sdza    NoneFlag[0]
0634	2E3B	jmp     _L28
				;11		{
				;12			if(0 == KeyFirstPressFlag)
0635	50CA	sz      KeyFirstPressFlag[0]
0636	2E3D	jmp     _L29
				;13			{
				;14				KeyFirstPressFlag = 1;//按键按下标记		
0637	0F01	mov     a, 1H
0638	40CA	mov     KeyFirstPressFlag[0], a
				;15				return 0;
0639	5F54	clr     ra
063A	2E60	jmp     _L27
				;16			}
				;17		}
				;18		else
				;19			KeyFirstPressFlag = 1;//按键按下标记	
				_L28:
063B	0F01	mov     a, 1H
063C	40CA	mov     KeyFirstPressFlag[0], a
				;20		
				;21		
				;22		//KeyFirstPressFlag = 1;//按键按下标记
				;23		if(KeySitchON != KeySwitchStatus)//switch 开启判定
				_L29:
063D	5751	sdza    KeySwitchStatus[0]
063E	2E5E	jmp     _L35
				;24		{
				;25			return 1;
				_L35:
065E	0F01	mov     a, 1H
065F	40D4	mov     ra, a
				;26		}
				;27		
				;28	  	LED_DOWN  = LedOpen; 	
063F	3520	clr     PB2
				;29		
				;30		
				;31		if ((0 == Temp_Num1_L)&&(Temp_Num1_H > 0))
0640	50C2	sz      Temp_Num1_L[0]
0641	2E50	jmp     _L31
0642	50C1	sz      Temp_Num1_H[0]
0643	2E45	jmp     _LI1
0644	2E50	jmp     _L31
				;32		{
				;33			Temp_Num1_L = 5;
				_LI1:
0645	0F05	mov     a, 5H
0646	40C2	mov     Temp_Num1_L[0], a
				;34			Temp_Num1_H --;
0647	57C1	sdz     Temp_Num1_H[0]
0648	2E4B	jmp     _L32
				;35							
				;36			if(0 == Temp_Num1_H)
				;37			{
				;38				Temp_Num1_H;
0649	4741	mov     a, Temp_Num1_H[0]
064A	40D4	mov     ra, a
				;39			}
				;40			D_NUM3(Temp_Num1_H);
				_L32:
064B	4741	mov     a, Temp_Num1_H[0]
064C	40DF	mov     high, a
064D	0FC8	mov     a, C8H
064E	25A5	call    _display16
064F	2E59	jmp     _L42
				;41			D_NUM4(Temp_Num1_L);	
				;42		}
				;43		else if((5 == Temp_Num1_L)&&(3 == Temp_Num1_H ))
				_L31:
0650	4742	mov     a, Temp_Num1_L[0]
0651	0A05	sub     a, 5H
0652	390A	snz     Z
0653	2E58	jmp     _L34
0654	4741	mov     a, Temp_Num1_H[0]
0655	0A03	sub     a, 3H
0656	3D0A	sz      Z
0657	2E60	jmp     _L27
				;44		{
				;45						
				;46		}
				;47		else
				;48		{
				;49			Temp_Num1_L = 0;
				_L34:
0658	5F42	clr     Temp_Num1_L[0]
				;50			D_NUM4(Temp_Num1_L);
				_L42:
0659	4742	mov     a, Temp_Num1_L[0]
065A	40DF	mov     high, a
065B	0FCA	mov     a, CAH
065C	25A5	call    _display16
065D	2E60	jmp     _L27
				;51		}
				;52	}
				_L27:
0660	4754	mov     a, ra
0661	0003	ret
				;53	unsigned char KeyUpProcess(void)
				;54	{	
				;55	//	KeyPressFlag = 1;
				;56		Beep1 = BeepOpen;
				_KeyUpProcess:
				_KeyUpProcess:
0662	3194	set     PA3
				;57		if(1 == NoneFlag)//无人下
0663	572C	sdza    NoneFlag[0]
0664	2E6B	jmp     _L44
				;58		{
				;59			if(0 == KeyFirstPressFlag)
0665	50CA	sz      KeyFirstPressFlag[0]
0666	2E6D	jmp     _L45
				;60			{
				;61				KeyFirstPressFlag = 1;//按键按下标记		
0667	0F01	mov     a, 1H
0668	40CA	mov     KeyFirstPressFlag[0], a
				;62				return 0;
0669	5F54	clr     ra
066A	2E93	jmp     _L43
				;63			}
				;64		}
				;65		else
				;66			KeyFirstPressFlag = 1;//按键按下标记	
				_L44:
066B	0F01	mov     a, 1H
066C	40CA	mov     KeyFirstPressFlag[0], a
				;67		//KeyFirstPressFlag = 1;//按键按下标记	
				;68		if(KeySitchON != KeySwitchStatus)
				_L45:
066D	5751	sdza    KeySwitchStatus[0]
066E	2E91	jmp     _L50
				;69		{
				;70			return 1;
				_L50:
0691	0F01	mov     a, 1H
0692	40D4	mov     ra, a
				;71		}
				;72		LED_UP    = LedOpen;  	
066F	34A0	clr     PB1
				;73	
				;74	
				;75		if ((5 == Temp_Num1_L)&&(Temp_Num1_H < 9))
0670	4742	mov     a, Temp_Num1_L[0]
0671	0A05	sub     a, 5H
0672	390A	snz     Z
0673	2E8A	jmp     _L47
0674	0F08	mov     a, 8H
0675	4241	sub     a, Temp_Num1_H[0]
0676	380A	snz     C
0677	2E8A	jmp     _L47
				;76		{
				;77			Temp_Num1_L = 0;
0678	5F42	clr     Temp_Num1_L[0]
				;78			Temp_Num1_H ++;
0679	54C1	inc     Temp_Num1_H[0]
				;79			if(Temp_Num1_H == 9)
067A	4741	mov     a, Temp_Num1_H[0]
067B	0A09	sub     a, 9H
067C	390A	snz     Z
067D	2E82	jmp     _L48
				;80			{
				;81				Temp_Num1_H = 8 ;
067E	0F08	mov     a, 8H
067F	40C1	mov     Temp_Num1_H[0], a
				;82				Temp_Num1_L = 5;				
0680	0F05	mov     a, 5H
0681	40C2	mov     Temp_Num1_L[0], a
				;83			}
				;84			D_NUM3(Temp_Num1_H);
				_L48:
0682	4741	mov     a, Temp_Num1_H[0]
0683	40DF	mov     high, a
0684	0FC8	mov     a, C8H
0685	25A5	call    _display16
				;85			D_NUM4(Temp_Num1_L);	
0686	4742	mov     a, Temp_Num1_L[0]
0687	40DF	mov     high, a
0688	0FCA	mov     a, CAH
0689	2E8F	jmp     _L51
				;86		}
				;87		else 
				;88		{
				;89			Temp_Num1_L = 5;
				_L47:
068A	0F05	mov     a, 5H
068B	40C2	mov     Temp_Num1_L[0], a
				;90			D_NUM3(Temp_Num1_H);//好像有的问题
068C	4741	mov     a, Temp_Num1_H[0]
068D	40DF	mov     high, a
068E	0FC8	mov     a, C8H
				_L51:
068F	25A5	call    _display16
0690	2E93	jmp     _L43
				;91		}
				;92	}
				_L43:
0693	4754	mov     a, ra
0694	0003	ret
				;93	unsigned char KeySwitchProcess(void)
				;94	{
				;95	
				;96		Beep1 = BeepOpen;
				_KeySwitchProcess:
				_KeySwitchProcess:
0695	3194	set     PA3
				;97		if(1 == NoneFlag)//无人下
0696	572C	sdza    NoneFlag[0]
0697	2E9E	jmp     _L53
				;98		{
				;99			if(0 == KeyFirstPressFlag)
0698	50CA	sz      KeyFirstPressFlag[0]
0699	2EA0	jmp     _L54
				;100			{
				;101				KeyFirstPressFlag = 1;//按键按下标记		
069A	0F01	mov     a, 1H
069B	40CA	mov     KeyFirstPressFlag[0], a
				;102				return 0;
069C	5F54	clr     ra
069D	2EAC	jmp     _L52
				;103			}
				;104		}
				;105		else
				;106			KeyFirstPressFlag = 1;//按键按下标记		
				_L53:
069E	0F01	mov     a, 1H
069F	40CA	mov     KeyFirstPressFlag[0], a
				;107		//加热结束或关闭按键后清除
				;108		if(KeySitchOFF == KeySwitchStatus)
				_L54:
06A0	50D1	sz      KeySwitchStatus[0]
06A1	2EA8	jmp     _L55
				;109		{
				;110	 
				;111			LEDSwitch = LedOpen;    //  
06A2	3494	clr     PA1
				;112			KeySwitchStatus = KeySitchON;
06A3	0F01	mov     a, 1H
06A4	40D1	mov     KeySwitchStatus[0], a
				;113			ControlFlag 	= StatusSwitchON;
06A5	0F01	mov     a, 1H
06A6	408A	mov     ControlFlag[0], a
06A7	2EAC	jmp     _L52
				;114		}
				;115		else
				;116		{
				;117			LEDSwitch = LedClose;    //  
				_L55:
06A8	3094	set     PA1
				;118			KeySwitchStatus = KeySitchOFF;	
06A9	5F51	clr     KeySwitchStatus[0]
				;119			ControlFlag 	= StatusSwitchOFF;
06AA	0F02	mov     a, 2H
06AB	408A	mov     ControlFlag[0], a
				;120		}
				;121	}
				_L52:
06AC	4754	mov     a, ra
06AD	0003	ret
				;122	
				;file E:\MyWork\Sun\HTK_Project\Sun_test1\Sun_touch\LEDX4_V16\Src\IRCHQB.c
				;1	/*****************************
				;2	    红外遥控
				;3	*****************************/
				;4		//1us 		GCC_DELAY(2) 
				;5	 	//1ms 		GCC_DELAY(2000)
				;6	 	//2.272ms   GCC_DELAY(4544)
				;7	//
				;8	unsigned char BOOT_REPEATING_CODE_Judge() 
				;9	{ 
				;10	    bit TEMP_Flag = 1; 
				;11	    while((0 == IR_Out)&&(IRCount<10000))    // 等待高电平避开9毫秒低电平引导脉冲 
				_L59:
				_BOOT_REPEATING_CODE_Judge:
				_BOOT_REPEATING_CODE_Judge:
06AE	3EA0	sz      PB5
06AF	2EC2	jmp     _L60
06B0	0F0F	mov     a, FH
06B1	422F	sub     a, IRCount[0]
06B2	0F27	mov     a, 27H
06B3	5230	sbc     a, IRCount[1]
06B4	0F00	mov     a, 0H
06B5	5231	sbc     a, IRCount[2]
06B6	0F00	mov     a, 0H
06B7	5232	sbc     a, IRCount[3]
06B8	380A	snz     C
06B9	2EC2	jmp     _L60
				;12	 	{
				;13			GCC_CLRWDT();
06BA	0001	clr     wdt
				;14			IRCount++; 
06BB	0F01	mov     a, 1H
06BC	43AF	addm    a, IRCount[0]
06BD	0F00	mov     a, 0H
06BE	53B0	adcm    a, IRCount[1]
06BF	53B1	adcm    a, IRCount[2]
06C0	53B2	adcm    a, IRCount[3]
06C1	2EAE	jmp     _L59
				;15		}
				;16		
				;17		//GCC_DELAY()  0 <= n < 263690 一个指令周期相当于四个系统时钟周期
				;18	 	//8 M 0.000000125 * 4 = 0.0000005  --->0.5us
				;19	 	//1us 		GCC_DELAY(2) 
				;20	 	//1ms 		GCC_DELAY(2000)
				;21	 	//2.272ms   GCC_DELAY(4544)
				;22	 	Delay2272us;
				_L60:
06C2	0F04	mov     a, 4H
06C3	40DD	mov     Res, a
06C4	0F6C	mov     a, 6CH
06C5	6357	call    L0B57
				;23	    if( IR_Out == 0 ) 
06C6	1120	swapa   PB
06C7	1985	rr      ACC
06C8	0E07	and     a, 7H
06C9	40D4	mov     ra, a
06CA	0F01	mov     a, 1H
06CB	44D4	xorm    a, ra
06CC	0F01	mov     a, 1H
06CD	46D4	andm    a, ra
				;24	    { 
				;25	        TEMP_Flag = 1;      // 是连发码 
				;26	    } 
				;27	    else 
				;28	    { 
				;29	        TEMP_Flag = 0;      // 不是连发码，而是引导码 
				;30	    } 
				;31	    return TEMP_Flag; 
				;32	}
06CE	4754	mov     a, ra
06CF	0003	ret
				;33	unsigned char H_L_LEVEL_Judge()  //单个接收部分
				;34	{ 
				;35	    while( (IR_Out == 1)&& (IRCount<1000)) 
				_L63:
				_H_L_LEVEL_Judge:
				_H_L_LEVEL_Judge:
06D0	3AA0	snz     PB5
06D1	2EE4	jmp     _L64
06D2	0FE7	mov     a, E7H
06D3	422F	sub     a, IRCount[0]
06D4	0F03	mov     a, 3H
06D5	5230	sbc     a, IRCount[1]
06D6	0F00	mov     a, 0H
06D7	5231	sbc     a, IRCount[2]
06D8	0F00	mov     a, 0H
06D9	5232	sbc     a, IRCount[3]
06DA	380A	snz     C
06DB	2EE4	jmp     _L64
				;36		{
				;37			GCC_CLRWDT();
06DC	0001	clr     wdt
				;38			IRCount++; 
06DD	0F01	mov     a, 1H
06DE	43AF	addm    a, IRCount[0]
06DF	0F00	mov     a, 0H
06E0	53B0	adcm    a, IRCount[1]
06E1	53B1	adcm    a, IRCount[2]
06E2	53B2	adcm    a, IRCount[3]
06E3	2ED0	jmp     _L63
				;39		}  // 等待地址码第一位的高电平信号 
				;40		
				;41		IRCount = 0;
				_L64:
06E4	5F2F	clr     IRCount[0]
06E5	5F30	clr     IRCount[1]
06E6	5F31	clr     IRCount[2]
06E7	5F32	clr     IRCount[3]
				;42	   	Delay1150us;  // 测试实际延时约为 
06E8	0F02	mov     a, 2H
06E9	40DD	mov     Res, a
06EA	0F3C	mov     a, 3CH
06EB	6357	call    L0B57
				;43	    if ( IR_Out == 1) 
06EC	5F54	clr     ra
06ED	3EA0	sz      PB5
06EE	54D4	inc     ra
				;44	    { 
				;45	        return 1; 
				;46	    } 
				;47	    else 
				;48	    { 
				;49	        return 0; 
				;50	    } 
				;51	}
06EF	4754	mov     a, ra
06F0	0003	ret
				;52	unsigned char START_Judge() 
				;53	{ 
				;54	    unsigned char TEMP_Flag = 0;  //？？？
				_L73:
0701	5F54	clr     ra
				;55	    unsigned char i = 0; 
				;56	    //在正常无遥控信号时，一体化红外接收头输出是高电平，程序一直在循环。 
				;57	    //while ( IR_Out == 1) GCC_CLRWDT();    ; 
				;58	    //重复10次，目的是检测在6876~8352微秒内如果出现高电平就退出解码程序 
				;59	    GCC_CLRWDT();
				_START_Judge:
				_START_Judge:
06F1	0001	clr     wdt
				;60	 	if(1 != IR_Out)
06F2	3EA0	sz      PB5
06F3	2F01	jmp     _L73
06F4	0F08	mov     a, 8H
06F5	40D4	mov     ra, a
				;61	 	{
				;62	 		TEMP_Flag = 1;
06FE	0F01	mov     a, 1H
06FF	40D4	mov     ra, a
0700	2F02	jmp     _L70
				;63		    for(i =0;i <8; i++) 
				;64		    { 
				;65		        //DELAY_Us(800);      // 测试实际延时约为764~928us 
				;66				Delay800us;
				_L71:
06F6	0F01	mov     a, 1H
06F7	40DD	mov     Res, a
06F8	0F8E	mov     a, 8EH
06F9	6359	call    L0B59
				;67		        if ( IR_Out == 1 ) 
06FA	3EA0	sz      PB5
06FB	2F01	jmp     _L73
06FC	57D4	sdz     ra
06FD	2EF6	jmp     _L71
				;68		        { 
				;69		            TEMP_Flag = 0; 
				;70		            break; 
				;71		        } 
				;72		    }  	
				;73	    }
				;74	    return TEMP_Flag; 
				;75	}
				_L70:
0702	4754	mov     a, ra
0703	0003	ret
				;76	void DataSave(void)
				;77	{
				_DataSave:
				_DataSave:
0704	0F04	mov     a, 4H
0705	40DE	mov     _DataSave_2, a
				;78	    unsigned char i;
				;79		for(i =0;i <4; i++) 
0706	5F5F	clr     i[0]
075E	54DF	inc     i[0]
075F	57DE	sdz     _DataSave_2
0760	2F07	jmp     _L77
0761	0003	ret
				;80		{                
				;81			Datachange._bits.b7 = H_L_LEVEL_Judge(); 
				_L77:
0707	26D0	call    _L63
0708	40D4	mov     ra, a
0709	5BD4	rrc     ra
070A	5F54	clr     ra
070B	5BD4	rrc     ra
070C	7789	clr     Datachange[0].7
070D	4754	mov     a, ra
070E	4589	orm     a, Datachange[0]
				;82			Datachange._bits.b6 = H_L_LEVEL_Judge(); 
070F	26D0	call    _L63
0710	40D4	mov     ra, a
0711	0F01	mov     a, 1H
0712	46D4	andm    a, ra
0713	5954	rra     ra
0714	1985	rr      ACC
0715	0EC0	and     a, C0H
0716	40D4	mov     ra, a
0717	7709	clr     Datachange[0].6
0718	4754	mov     a, ra
0719	4589	orm     a, Datachange[0]
				;83			Datachange._bits.b5 = H_L_LEVEL_Judge(); 
071A	26D0	call    _L63
071B	40D4	mov     ra, a
071C	0F01	mov     a, 1H
071D	46D4	andm    a, ra
071E	5154	swapa   ra
071F	1885	rl      ACC
0720	0EE0	and     a, E0H
0721	40D4	mov     ra, a
0722	7689	clr     Datachange[0].5
0723	4754	mov     a, ra
0724	4589	orm     a, Datachange[0]
				;84			Datachange._bits.b4 = H_L_LEVEL_Judge(); 
0725	26D0	call    _L63
0726	40D4	mov     ra, a
0727	0F01	mov     a, 1H
0728	46D4	andm    a, ra
0729	5154	swapa   ra
072A	0EF0	and     a, F0H
072B	40D4	mov     ra, a
072C	7609	clr     Datachange[0].4
072D	4754	mov     a, ra
072E	4589	orm     a, Datachange[0]
				;85			Datachange._bits.b3 = H_L_LEVEL_Judge(); 
072F	26D0	call    _L63
0730	40D4	mov     ra, a
0731	0F01	mov     a, 1H
0732	46D4	andm    a, ra
0733	5154	swapa   ra
0734	1985	rr      ACC
0735	0EF8	and     a, F8H
0736	40D4	mov     ra, a
0737	7589	clr     Datachange[0].3
0738	4754	mov     a, ra
0739	4589	orm     a, Datachange[0]
				;86			Datachange._bits.b2 = H_L_LEVEL_Judge(); 
073A	26D0	call    _L63
073B	40D5	mov     rb, a
073C	0F01	mov     a, 1H
073D	46D5	andm    a, rb
073E	5F54	clr     ra
073F	50D5	sz      rb
0740	7154	set     ra.2
0741	7509	clr     Datachange[0].2
0742	4754	mov     a, ra
0743	4589	orm     a, Datachange[0]
				;87			Datachange._bits.b1 = H_L_LEVEL_Judge(); 
0744	26D0	call    _L63
0745	40D4	mov     ra, a
0746	0F01	mov     a, 1H
0747	46D4	andm    a, ra
0748	4754	mov     a, ra
0749	43D4	addm    a, ra
074A	7489	clr     Datachange[0].1
074B	4754	mov     a, ra
074C	4589	orm     a, Datachange[0]
				;88			Datachange._bits.b0 = H_L_LEVEL_Judge();                              
074D	26D0	call    _L63
074E	40D4	mov     ra, a
074F	0F01	mov     a, 1H
0750	46D4	andm    a, ra
0751	7409	clr     Datachange[0].0
0752	4754	mov     a, ra
0753	4589	orm     a, Datachange[0]
				;89			_datasave[i] =  Datachange.data; 
0754	0F85	mov     a, 85H
0755	435F	add     a, i[0]
0756	0083	mov     MP1, a
0757	0F00	mov     a, 0H
0758	1F01	clr     MP0
0759	1381	adcm    a, MP0
075A	0701	mov     a, MP0
075B	0084	mov     BP, a
075C	4709	mov     a, Datachange[0]
075D	0082	mov     [02H], a
				;90		} 
				;91		//功能处理
				;92	}
				;93	// 红外功能处理
				;94	void IR_FUN(void)
				;95	{
				;96	  	GCC_CLRWDT();     	
				_IR_FUN:
				_IR_FUN:
0762	0001	clr     wdt
				;97		StartFlag = START_Judge();
0763	26F1	call    _START_Judge
0764	40D4	mov     ra, a
0765	4754	mov     a, ra
0766	40AE	mov     StartFlag[0], a
				;98		if(1 == StartFlag)
0767	572E	sdza    StartFlag[0]
0768	2F6D	jmp     _L79
				;99		{
				;100			BOOT_REPEATING_CODE_Flag = BOOT_REPEATING_CODE_Judge(); 			
0769	26AE	call    _L59
076A	40D4	mov     ra, a
076B	4754	mov     a, ra
076C	40AD	mov     BOOT_REPEATING_CODE_Flag[0], a
				;101		}
				;102		if (StartFlag && !BOOT_REPEATING_CODE_Flag )  
				_L79:
076D	50AE	sz      StartFlag[0]
076E	2F70	jmp     _LI2
076F	2F87	jmp     _L78
				_LI2:
0770	50AD	sz      BOOT_REPEATING_CODE_Flag[0]
0771	2F87	jmp     _L78
				;103		{
				;104			DataSave();
0772	2704	call    _DataSave
				;105			KeyCountOpenflag = 1;
0773	0F01	mov     a, 1H
0774	40CF	mov     KeyCountOpenflag[0], a
				;106			switch(_datasave[2])
0775	4707	mov     a, _datasave[2]
0776	40E3	mov     _TouchFun_2, a
0777	4763	mov     a, _TouchFun_2
0778	0A10	sub     a, 10H
0779	3D0A	sz      Z
077A	2F84	jmp     _L81
077B	0A10	sub     a, 10H
077C	3D0A	sz      Z
077D	2F86	jmp     _L82
077E	4763	mov     a, _TouchFun_2
077F	0A40	sub     a, 40H
0780	390A	snz     Z
0781	2F87	jmp     _L78
				;107			{
				;108			 	case 0x40://UP
				;109			 		KeyUpProcess();
0782	2662	call    _KeyUpProcess
				;110			 	break;
0783	2F87	jmp     _L78
				;111			 	case 0x10://Down
				;112			 		KeyDownProcess();
				_L81:
0784	2632	call    _KeyDownProcess
				;113			 	break;		 	
0785	2F87	jmp     _L78
				;114			 	case 0x20://Open
				;115			 		KeySwitchProcess()	;
				_L82:
0786	2695	call    _KeySwitchProcess
				_L78:
0787	0003	ret
				;116			 	break;		 	
				;117			 	// case 0x60://Set
				;118			 		
				;119			 	// break;		 	
				;120			 	default : 
				;121			 		//_pd6 =~_pd6;
				;122			 	break;			
				;123			}
				;124		} 
				;125	}
				data .SECTION 'DATA'
				__intc0 DB DUP (?) ; __intc0
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__tmr DB DUP (?) ; __tmr
				__tmrc DB DUP (?) ; __tmrc
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pbpu DB DUP (?) ; __pbpu
				__adrl DB DUP (?) ; __adrl
				__adrh DB DUP (?) ; __adrh
				__adcr0 DB DUP (?) ; __adcr0
				__adcr1 DB DUP (?) ; __adcr1
				__acerl DB DUP (?) ; __acerl
				__pd DB DUP (?) ; __pd
				__pdc DB DUP (?) ; __pdc
				__pdpu DB DUP (?) ; __pdpu
				POR_ID DB DUP (?) ; POR_ID
				_datasave DB DUP (?) ; _datasave
				Datachange DB DUP (?) ; Datachange
				ControlFlag DB DUP (?) ; ControlFlag
				intTemp1 DB 2 DUP (?) ; intTemp1
				ADCCompleteFlag DB DUP (?) ; ADCCompleteFlag
				ADCCount DB 2 DUP (?) ; ADCCount
				R_valueSum DB 4 DUP (?) ; R_valueSum
				R_value DB 4 DUP (?) ; R_value
				T_value DB 4 DUP (?) ; T_value
				dat DB 2 DUP (?) ; dat
				T_valueGet DB DUP (?) ; T_valueGet
				E1WaringFlag DB DUP (?) ; E1WaringFlag
				E2WaringFlag DB DUP (?) ; E2WaringFlag
				NoneErrorTimerCount DB 4 DUP (?) ; NoneErrorTimerCount
				NoneTimerCount DB 4 DUP (?) ; NoneTimerCount
				personTimerCount DB 2 DUP (?) ; personTimerCount
				PersonCheckDisable DB DUP (?) ; PersonCheckDisable
				NoneFlag DB DUP (?) ; NoneFlag
				BOOT_REPEATING_CODE_Flag DB DUP (?) ; BOOT_REPEATING_CODE_Flag
				StartFlag DB DUP (?) ; StartFlag
				IRCount DB 4 DUP (?) ; IRCount
				timer1hourFlag DB DUP (?) ; timer1hourFlag
				timer3sFlag DB DUP (?) ; timer3sFlag
				timerFlag DB DUP (?) ; timerFlag
				timerCount DB 4 DUP (?) ; timerCount
				timerCountSet DB 4 DUP (?) ; timerCountSet
				KeyStatus DB DUP (?) ; KeyStatus
				Temp_Num2_H DB DUP (?) ; Temp_Num2_H
				Temp_Num2_L DB DUP (?) ; Temp_Num2_L
				Temp_Num1_H DB DUP (?) ; Temp_Num1_H
				Temp_Num1_L DB DUP (?) ; Temp_Num1_L
				BarDisplayNum4 DB DUP (?) ; BarDisplayNum4
				BarDisplayNum3 DB DUP (?) ; BarDisplayNum3
				BarDisplayNum2 DB DUP (?) ; BarDisplayNum2
				BarDisplayNum1 DB DUP (?) ; BarDisplayNum1
				BarTimerCount DB 2 DUP (?) ; BarTimerCount
				BarNum DB DUP (?) ; BarNum
				KeyFirstPressFlag DB DUP (?) ; KeyFirstPressFlag
				C_Display DB DUP (?) ; C_Display
				CaValue DB DUP (?) ; CaValue
				C8Value2 DB DUP (?) ; C8Value2
				C8Value DB DUP (?) ; C8Value
				KeyCountOpenflag DB DUP (?) ; KeyCountOpenflag
				KeyCount DB DUP (?) ; KeyCount
				KeySwitchStatus DB DUP (?) ; KeySwitchStatus
				KeyPressFlag DB DUP (?) ; KeyPressFlag
				BeepCount DB DUP (?) ; BeepCount
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				rf DB DUP (?)
				rg DB DUP (?)
				r100 DB DUP (?)
				r200 DB DUP (?)
				Res DB 2 DUP (?) ; Res
				_DataSave_2 DB DUP (?)
				high DB DUP (?) ; high
				mid DB DUP (?) ; mid
				_SunControl_2 DB DUP (?)
				_TouchFun_2 DB DUP (?)
				flag DB DUP (?) ; flag
